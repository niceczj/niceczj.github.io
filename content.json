{"meta":{"title":"Jay的狗窝","subtitle":"","description":"一个有体系的个人博客","author":"Jay Cai","url":"http://www.niceczj.online","root":"/"},"pages":[{"title":"about","date":"2020-10-29T14:57:41.000Z","updated":"2020-10-30T15:38:42.706Z","comments":false,"path":"about/index.html","permalink":"http://www.niceczj.online/about/index.html","excerpt":"","text":""},{"title":"archives","date":"2020-10-30T11:30:23.000Z","updated":"2020-10-30T15:38:42.669Z","comments":false,"path":"archives/index.html","permalink":"http://www.niceczj.online/archives/index.html","excerpt":"","text":""},{"title":"Categories","date":"2020-10-29T14:57:31.000Z","updated":"2020-10-30T15:38:42.725Z","comments":false,"path":"categories/index.html","permalink":"http://www.niceczj.online/categories/index.html","excerpt":"","text":""},{"title":"Tags","date":"2020-10-29T14:57:29.000Z","updated":"2020-10-30T15:39:04.681Z","comments":false,"path":"tags/index.html","permalink":"http://www.niceczj.online/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"(二) PostProcesser","slug":"二-PostProcesser","date":"2020-10-31T16:19:11.000Z","updated":"2020-10-31T16:19:11.719Z","comments":true,"path":"2020/11/01/二-PostProcesser/","link":"","permalink":"http://www.niceczj.online/2020/11/01/%E4%BA%8C-PostProcesser/","excerpt":"什么是 PostProcesserSpring 中提供了多种 PostProcessor（后置处理器）处理 Bean 或者 BeanFactory。PostProcessor 是 Spring 中一个非常重要的扩展点，不同的 PostProcessor 的不同方法会在指定的阶段被执行。很多核心的功能都是由对应的 PostProcessor 扩展而来，比如处理注解注入的AutowiredAnnotationBeanPostProcessor。","text":"什么是 PostProcesserSpring 中提供了多种 PostProcessor（后置处理器）处理 Bean 或者 BeanFactory。PostProcessor 是 Spring 中一个非常重要的扩展点，不同的 PostProcessor 的不同方法会在指定的阶段被执行。很多核心的功能都是由对应的 PostProcessor 扩展而来，比如处理注解注入的AutowiredAnnotationBeanPostProcessor。 容器级别容器级别的 PostProcesser 是为 IOC 容器服务，处理的是整个容器中 BeanDefinitions 。 BeanFactoryPostProcessor顾名思义，BeanFactoryPostProcessor是 Spring 中的底层 IOC 容器 BeanFactory 的后置处理器。 方法：修改 BeanDefinition该接口只有一个方法，会在 Bean 实例化前修改 BeanDefinition： @FunctionalInterface public interface BeanFactoryPostProcessor &#123; /** * 在bean factory 初始化之后，修改 bean definition * 此时 bean definition 已加载但未实例化 */ void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException; &#125; 执行时机BeanFactoryPostProcessor#postProcessBeanFactory会在 refresh 中执行 Bean 处理前执行。实际上全部委托给PostProcessorRegistrationDelegate执行。 public void refresh() throws BeansException, IllegalStateException &#123; synchronized (this.startupShutdownMonitor) &#123; try &#123; // BeanFactory的一些准备工作以及一个钩子方法的单独实现 ...... invokeBeanFactoryPostProcessors(beanFactory); ...... //开始进行 Bean 级别的操作 &#125; &#125; &#125; protected void invokeBeanFactoryPostProcessors(ConfigurableListableBeanFactory beanFactory) &#123; // 全部委托给`PostProcessorRegistrationDelegate`执行 PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors(beanFactory, getBeanFactoryPostProcessors()); &#125; BeanDefinitionRegistryPostProcessorBeanDefinitionRegistryPostProcessor继承于BeanFactoryPostProcessor。BeanDefinitionRegistryPostProcessor有一些很重要的实现类，比如ConfigurationClassPostProcessor，该后置处理器会在(三) 配置类处理中详细解析。 方法：注册新的 BeanDefinitionBeanDefinitionRegistryPostProcessor额外提供了一个方法用于注册新的 BeanDefinition： public interface BeanDefinitionRegistryPostProcessor extends BeanFactoryPostProcessor &#123; /** * 在 BeanDefinitionRegistry 初始化之后，注册新的 bean definition */ void postProcessBeanDefinitionRegistry(BeanDefinitionRegistry registry) throws BeansException; &#125; 执行时机BeanDefinitionRegistryPostProcessor由于是BeanFactoryPostProcessor子类，所以也是被当做BeanFactoryPostProcessor一样在PostProcessorRegistrationDelegate#invokeBeanFactoryPostProcessors执行。但是BeanDefinitionRegistryPostProcessor#postProcessBeanDefinitionRegistry的语义是注册 BeanDefinition，所以他的执行时机是在修改 BeanDefinition，也就是普通的BeanFactoryPostProcessor#postProcessBeanFactory前面的。 invokeBeanFactoryPostProcessors跟踪PostProcessorRegistrationDelegate#invokeBeanFactoryPostProcessors可以了解BeanFactoryPostProcessor以及BeanDefinitionRegistryPostProcessor的执行逻辑： 获取refresh前注册的BeanFactoryPostProcessor以及容器中查找到的BeanDefinitionRegistryPostProcessor; 按照PriorityOrdered、Ordered、普通这个顺序执行BeanDefinitionRegistryPostProcessor#postProcessBeanDefinitionRegistry; 再按照BeanDefinitionRegistryPostProcessor、BeanFactoryPostProcessor的顺序执行postProcessBeanFactory; 获取容器中查找到的BeanFactoryPostProcessor; 按照PriorityOrdered、Ordered、普通这个顺序执行BeanFactoryPostProcessor#postProcessBeanFactory; public static void invokeBeanFactoryPostProcessors( ConfigurableListableBeanFactory beanFactory, List&lt;BeanFactoryPostProcessor> beanFactoryPostProcessors) &#123; Set&lt;String> processedBeans = new HashSet&lt;>(); // 先执行 BeanDefinitionRegistryPostProcessors if (beanFactory instanceof BeanDefinitionRegistry) &#123; BeanDefinitionRegistry registry = (BeanDefinitionRegistry) beanFactory; // BeanFactoryPostProcessors List&lt;BeanFactoryPostProcessor> regularPostProcessors = new ArrayList&lt;>(); // BeanDefinitionRegistryPostProcessors List&lt;BeanDefinitionRegistryPostProcessor> registryProcessors = new ArrayList&lt;>(); // 先分类，如果`BeanDefinitionRegistryPostProcessor`就先执行 for (BeanFactoryPostProcessor postProcessor : beanFactoryPostProcessors) &#123; if (postProcessor instanceof BeanDefinitionRegistryPostProcessor) &#123; BeanDefinitionRegistryPostProcessor registryProcessor = (BeanDefinitionRegistryPostProcessor) postProcessor; registryProcessor.postProcessBeanDefinitionRegistry(registry); registryProcessors.add(registryProcessor); &#125; else &#123; regularPostProcessors.add(postProcessor); &#125; &#125; // 先执行实现了`PriorityOrdered`的`BeanDefinitionRegistryPostProcessors` List&lt;BeanDefinitionRegistryPostProcessor> currentRegistryProcessors = new ArrayList&lt;>(); String[] postProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, true, false); for (String ppName : postProcessorNames) &#123; if (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) &#123; currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class)); processedBeans.add(ppName); &#125; &#125; sortPostProcessors(currentRegistryProcessors, beanFactory); registryProcessors.addAll(currentRegistryProcessors); invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry); currentRegistryProcessors.clear(); // 再执行实现了`Ordered`的`BeanDefinitionRegistryPostProcessors` postProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, true, false); for (String ppName : postProcessorNames) &#123; if (!processedBeans.contains(ppName) &amp;&amp; beanFactory.isTypeMatch(ppName, Ordered.class)) &#123; currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class)); processedBeans.add(ppName); &#125; &#125; sortPostProcessors(currentRegistryProcessors, beanFactory); registryProcessors.addAll(currentRegistryProcessors); invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry); currentRegistryProcessors.clear(); // 最后执行普通的`BeanDefinitionRegistryPostProcessors` boolean reiterate = true; while (reiterate) &#123; reiterate = false; postProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, true, false); for (String ppName : postProcessorNames) &#123; if (!processedBeans.contains(ppName)) &#123; currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class)); processedBeans.add(ppName); reiterate = true; &#125; &#125; sortPostProcessors(currentRegistryProcessors, beanFactory); registryProcessors.addAll(currentRegistryProcessors); invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry); currentRegistryProcessors.clear(); &#125; // 执行完了`BeanDefinitionRegistryPostProcessors#postProcessBeanDefinitionRegistry` // 再依次执行`BeanDefinitionRegistryPostProcessor#postProcessBeanFactory`、`BeanDefinitionRegistryPostProcessor#postProcessBeanFactory` invokeBeanFactoryPostProcessors(registryProcessors, beanFactory); invokeBeanFactoryPostProcessors(regularPostProcessors, beanFactory); &#125; // Do not initialize FactoryBeans here: We need to leave all regular beans // 再去容器中查找`BeanFactoryPostProcessor` // currentRegistryProcessors 大多数是`ApplicationContextInitializer`或者手动new的，所以这里不会与前面重复 String[] postProcessorNames = beanFactory.getBeanNamesForType(BeanFactoryPostProcessor.class, true, false); ...... // 后面与BeanDefinitionRegistryPostProcessor的逻辑是一样的，也是排序执行 &#125; Bean 级别在 IOC 容器批量修改 Bean Definition 之后，BeanPostProcessor 提供了对单个Bean的后置处理器。 BeanPostProcessorBeanPostProcessor是 Bean 级别后置处理器的父类。 方法：初始化前/** * 在 Bean 实例化之后，初始化之前被执行 */ default Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException &#123; return bean; &#125; 执行时机实例化之后。 方法：初始化后/** * 在 Bean 实例化之后，且初始化后被执行 */ default Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException &#123; return bean; &#125; 执行时机postProcessBeforeInitialization之后。 InstantiationAwareBeanPostProcessorInstantiationAwareBeanPostProcessor 继承自BeanPostProcessor。从名字的语义来看，就是对实例化前后进行了一个 Aware 切面。在 Bean 实例化前后提供了额外三个钩子方法。注意Instantiation 与 Instantization两个单词，前者是实例化，后者是初始化。 方法：实例化前default Object postProcessBeforeInstantiation(Class&lt;?> beanClass, String beanName) throws BeansException &#123; return null; &#125; 执行时机目标对象实例化之前调用，可以用生成代理对象。 方法：实例化后default boolean postProcessAfterInstantiation(Object bean, String beanName) throws BeansException &#123; return true; &#125; 执行时机在目标对象实例化之后调用，这个时候对象已经被实例化，但是该实例的属性还未被设置。 方法：属性值修改对属性值的修改，比如自动装配，就是在这实现的。 &#x2F;** * 对属性值进行修改 *&#x2F; default PropertyValues postProcessProperties(PropertyValues pvs, Object bean, String beanName) throws BeansException &#123; return null; &#125; 执行时机postProcessProperties是postProcessAfterInstantiation执行返回 true 时，才会执行。 SmartInstantiationAwareBeanPostProcessorSmartInstantiationAwareBeanPostProcessor继承自InstantiationAwareBeanPostProcessor。SmartInstantiationAwareBeanPostProcessor 是一个工具类， 方法：预测 postProcessBeforeInstantiation 返回的最终类型@Nullable default Class&lt;?> predictBeanType(Class&lt;?> beanClass, String beanName) throws BeansException &#123; return null; &#125; 方法：确认构造函数SmartInstantiationAwareBeanPostProcessor#determineCandidateConstructors会在实例化（AbstractAutowireCapableBeanFactory#createBeanInstance）中用到 default Constructor&lt;?>[] determineCandidateConstructors(Class&lt;?> beanClass, String beanName) throws BeansException &#123; return null; &#125; 方法：提前暴露的bean引用该方法会在循环依赖处理中被用到。 default Object getEarlyBeanReference(Object bean, String beanName) throws BeansException &#123; return bean; &#125; MergedBeanDefinitionPostProcessorMergedBeanDefinitionPostProcessor是专门处理合并后的RootBeanDefinition（处理继承关系）。 方法：处理合并后的RootBeanDefinitionvoid postProcessMergedBeanDefinition(RootBeanDefinition beanDefinition, Class&lt;?> beanType, String beanName); DestructionAwareBeanPostProcessorDestructionAwareBeanPostProcessor是销毁前的后置处理器。比如CommonAnnotationBeanPostProcessor就会处理标准注解@PreDestroy。 方法：销毁前的处理void postProcessBeforeDestruction(Object bean, String beanName) throws BeansException; 一些重要的PostProcessor 名称 实现接口 作用 ApplicationContextAwareProcessor BeanPostProcessor 执行 Aware 回调 ConfigurationPropertiesBindingPostProcessor BeanPostProcessor 绑定PropertySources 至 对应的@ConfigurationProperties 配置Bean上。如Server.port –&gt; ServerProperties ConfigurationClassPostProcessor BeanDefinitionRegistryPostProcessor 扫描注册配置类以及@Bean、@Component AnnotationAwareAspectJAutoProxyCreator SmartInstantiationAwareBeanPostProcessor 对AOP对象进行代理 CommonAnnotationBeanPostProcessor InstantiationAwareBeanPostProcessor、MergedBeanDefinitionPostProcessor、DestructionAwareBeanPostProcessor 对JSR-250 @Resource、@PostConstruct 、@PreDestroy等注解的支持 AutowiredAnnotationBeanPostProcessor SmartInstantiationAwareBeanPostProcessor、MergedBeanDefinitionPostProcessor 对@Autowire、@Value、@Inject 注入相关注解的支持 ApplicationListenerDetector DestructionAwareBeanPostProcessor、MergedBeanDefinitionPostProcessor ApplicationListener 注册和移除至事件广播器 总结其实 Spring 的作者们的确花了不少时间在命名上。我们只要观察对应后置处理器的语义，基本上就能猜测到改处理器的执行时机。","categories":[{"name":"主流框架","slug":"主流框架","permalink":"http://www.niceczj.online/categories/%E4%B8%BB%E6%B5%81%E6%A1%86%E6%9E%B6/"},{"name":"Spring","slug":"主流框架/Spring","permalink":"http://www.niceczj.online/categories/%E4%B8%BB%E6%B5%81%E6%A1%86%E6%9E%B6/Spring/"},{"name":"Spring Framework","slug":"主流框架/Spring/Spring-Framework","permalink":"http://www.niceczj.online/categories/%E4%B8%BB%E6%B5%81%E6%A1%86%E6%9E%B6/Spring/Spring-Framework/"}],"tags":[]},{"title":"(一) BeanDefinition","slug":"一-BeanDefinition","date":"2020-10-31T16:18:55.000Z","updated":"2020-10-31T16:20:04.756Z","comments":true,"path":"2020/11/01/一-BeanDefinition/","link":"","permalink":"http://www.niceczj.online/2020/11/01/%E4%B8%80-BeanDefinition/","excerpt":"什么是BeanDefinitionBeanDefinition是 bean 在 spring 中的元信息。理解BeanDefinition，对后续列理解 Bean 生命周期非常重要。","text":"什么是BeanDefinitionBeanDefinition是 bean 在 spring 中的元信息。理解BeanDefinition，对后续列理解 Bean 生命周期非常重要。 继承关系重点关注两个子类： AbstractBeanDefinition：核心抽象，定义核心的属性和方法。 GenericBeanDefinition：标准一站式类。兼备RootBeanDefinition与ChildBeanDefinition。并有动态设置父 Bean 的能力。 名称 作用 AbstractBeanDefinition 核心抽象，定义核心的属性和方法。其他的所有实现类都继承或者组合它。 AnnotatedBeanDefinition 拥有注解元数据和工厂方法元数据接口。 RootBeanDefinition merged 后的 BeanDefinition。 ChildBeanDefinition 可以让子 BeanDefinition 继承父 BeanDefinition 的能力。 GenericBeanDefinition 标准一站式类。兼备RootBeanDefinition与ChildBeanDefinition。并有动态设置父 Bean 的能力 AnnotatedGenericBeanDefinition @Configuration配置类的元数据。 ScannedGenericBeanDefinition @Component元数据。 核心属性 字段 xml配置 注解配置 作用 beanClass &lt;bean class=&quot;&quot;&gt; Bean 全限定名，必须是可初始化的具体类。 beanName &lt;bean id=&quot;&quot;&gt; @Bean(&quot;&quot;) scope &lt;bean scope=&quot;&quot;&gt; @Scope 作用域。singleton、prototype 等 constructorArgumentValues &lt;constructor-arg type=&quot;int&quot; value=&quot;7500000&quot;/&gt; 构造器参数。用于依赖注入。 propertyValues &lt;property name=&quot;beanTwo&quot; ref=&quot;yetAnotherBean&quot;/&gt; 属性设置。用于依赖注入。 autowireMode &lt;bean id=&quot;user&quot; autowire=&quot;&quot;&gt; 默认是NO，即需要通过注解@autowire等注解显式的注入 initMethodName &lt;bean init-method=&quot;&quot; &gt; @Bean(initMethod =&quot;&quot; destroyMethodName &lt;bean destroy-method=&quot;&quot;&gt; @Bean(destroyMethod = &quot;&quot;) dependsOn &lt;bean depends-on=&quot;&quot;&gt; @DependsOn lazyInit &lt;bean lazy-init=&quot;&quot;&gt; @Lazy 是否懒加载 primary &lt;bean primary=&quot;&quot;&gt; @primary 是否为首选项 factoryBeanName &lt;bean factory-bean=&quot;&quot;&gt; 构造正如继承关系所说，GenericBeanDefinition是最常用的实现类，官方也对应的提供了构造类BeanDefinitionBuilder： protected final AbstractBeanDefinition parseInternal(Element element, ParserContext parserContext) &#123; BeanDefinitionBuilder builder = BeanDefinitionBuilder.genericBeanDefinition(); builder.setLazyInit(true); return builder.getBeanDefinition(); &#125; 其他的实现类利用构造函数new即可。 注册手动构造BeanDefinition后，我们也需要手动注册到容器中去： 带名字BeanDefinitionRegistry#registerBeanDefinitionpublic void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) &#123; BeanDefinition annotationProcessor = BeanDefinitionBuilder .genericBeanDefinition(PropertySourcesPlaceholderConfigurer.class) .getBeanDefinition(); registry.registerBeanDefinition( PropertySouorcesPlaceholderConfigurer.class.getName(), annotationProcessor); &#125; BeanDefinitionReaderUtils.registerBeanDefinition这种方式也就是 Spring 扫描注册 Component（ClassPathBeanDefinitionScanner#doScan）的底层实现。 BeanDefinitionHolder definitionHolder = new BeanDefinitionHolder(abd, beanName); definitionHolder = AnnotationConfigUtils.applyScopedProxyMode(scopeMetadata, definitionHolder, this.registry); BeanDefinitionReaderUtils.registerBeanDefinition(definitionHolder, this.registry); 不带名字BeanDefinitionReaderUtils#registerWithGeneratedNameprivate void registerServiceAnnotationBeanPostProcessor(Set&lt;String> packagesToScan, BeanDefinitionRegistry registry) &#123; BeanDefinitionBuilder builder = rootBeanDefinition(ServiceAnnotationBeanPostProcessor.class); builder.addConstructorArgValue(packagesToScan); builder.setRole(BeanDefinition.ROLE_INFRASTRUCTURE); AbstractBeanDefinition beanDefinition = builder.getBeanDefinition(); BeanDefinitionReaderUtils.registerWithGeneratedName(beanDefinition, registry); &#125; 直接注册实例对象SingletonBeanRegistry#registerSingleton除了BeanDefinition之外，你也可以直接注册实例对象： context.getBeanFactory(). registerSingleton(AnnotationConfigUtils.CONFIGURATION_BEAN_NAME_GENERATOR,this.beanNameGenerator);","categories":[{"name":"主流框架","slug":"主流框架","permalink":"http://www.niceczj.online/categories/%E4%B8%BB%E6%B5%81%E6%A1%86%E6%9E%B6/"},{"name":"Spring","slug":"主流框架/Spring","permalink":"http://www.niceczj.online/categories/%E4%B8%BB%E6%B5%81%E6%A1%86%E6%9E%B6/Spring/"},{"name":"Spring Framework","slug":"主流框架/Spring/Spring-Framework","permalink":"http://www.niceczj.online/categories/%E4%B8%BB%E6%B5%81%E6%A1%86%E6%9E%B6/Spring/Spring-Framework/"}],"tags":[]},{"title":"(零) Spring Framework系列纲要","slug":"零-Spring-Framework系列纲要","date":"2020-10-31T16:17:50.000Z","updated":"2020-10-31T16:17:50.989Z","comments":true,"path":"2020/11/01/零-Spring-Framework系列纲要/","link":"","permalink":"http://www.niceczj.online/2020/11/01/%E9%9B%B6-Spring-Framework%E7%B3%BB%E5%88%97%E7%BA%B2%E8%A6%81/","excerpt":"","text":"《Spring Framework系列》是笔者准备用最小的篇幅，结合源码总结 Spring Framework 中的最核心和最常用的模块。目的是拥有可以快速排查问题以及个人项目集成 Spring 的能力。目前计划分为以下几个章节： (一) BeanDefinition (二) PostProcesser (三) 配置类处理 (四) Spring Event getBean 循环依赖 refresh Bean生命周期 AOP","categories":[{"name":"主流框架","slug":"主流框架","permalink":"http://www.niceczj.online/categories/%E4%B8%BB%E6%B5%81%E6%A1%86%E6%9E%B6/"},{"name":"Spring","slug":"主流框架/Spring","permalink":"http://www.niceczj.online/categories/%E4%B8%BB%E6%B5%81%E6%A1%86%E6%9E%B6/Spring/"},{"name":"Spring Framework","slug":"主流框架/Spring/Spring-Framework","permalink":"http://www.niceczj.online/categories/%E4%B8%BB%E6%B5%81%E6%A1%86%E6%9E%B6/Spring/Spring-Framework/"}],"tags":[]}],"categories":[{"name":"主流框架","slug":"主流框架","permalink":"http://www.niceczj.online/categories/%E4%B8%BB%E6%B5%81%E6%A1%86%E6%9E%B6/"},{"name":"Spring","slug":"主流框架/Spring","permalink":"http://www.niceczj.online/categories/%E4%B8%BB%E6%B5%81%E6%A1%86%E6%9E%B6/Spring/"},{"name":"Spring Framework","slug":"主流框架/Spring/Spring-Framework","permalink":"http://www.niceczj.online/categories/%E4%B8%BB%E6%B5%81%E6%A1%86%E6%9E%B6/Spring/Spring-Framework/"}],"tags":[]}