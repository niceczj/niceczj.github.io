{"meta":{"title":"Jay的狗窝","subtitle":"","description":"一个有体系的个人博客","author":"Jay Cai","url":"http://www.niceczj.online","root":"/"},"pages":[{"title":"about","date":"2020-10-29T14:57:41.000Z","updated":"2020-10-30T15:38:42.706Z","comments":false,"path":"about/index.html","permalink":"http://www.niceczj.online/about/index.html","excerpt":"","text":""},{"title":"Categories","date":"2020-10-29T14:57:31.000Z","updated":"2020-10-30T15:38:42.725Z","comments":false,"path":"categories/index.html","permalink":"http://www.niceczj.online/categories/index.html","excerpt":"","text":""},{"title":"Tags","date":"2020-10-29T14:57:29.000Z","updated":"2020-10-30T15:39:04.681Z","comments":false,"path":"tags/index.html","permalink":"http://www.niceczj.online/tags/index.html","excerpt":"","text":""},{"title":"archives","date":"2020-10-30T11:30:23.000Z","updated":"2020-10-30T15:38:42.669Z","comments":false,"path":"archives/index.html","permalink":"http://www.niceczj.online/archives/index.html","excerpt":"","text":""}],"posts":[{"title":"(七) refresh","slug":"七-refresh","date":"2020-11-08T15:26:08.000Z","updated":"2020-11-08T15:26:08.973Z","comments":true,"path":"2020/11/08/七-refresh/","link":"","permalink":"http://www.niceczj.online/2020/11/08/%E4%B8%83-refresh/","excerpt":"通过前面几个篇章的铺垫，现在可以更加系统的认识 Spring Framework 的启动方法：refresh。","text":"通过前面几个篇章的铺垫，现在可以更加系统的认识 Spring Framework 的启动方法：refresh。 refresh整个refresh方法看起来步骤繁多，抽象一点可以分为4个阶段：准备、BeanFactory 级别、Bean 级别、结束。 public void refresh() throws BeansException, IllegalStateException &#123; synchronized (this.startupShutdownMonitor) &#123; // 容器刷新前的准备，设置上下文状态，获取属性，验证必要的属性等. prepareRefresh(); // 获取BeanFactory ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory(); //配置标准的beanFactory，设置ClassLoader，设置SpEL表达式解析器等. prepareBeanFactory(beanFactory); try &#123; // 模板方法，允许在子类中对beanFactory进行后置处理。 postProcessBeanFactory(beanFactory); // 执行postProcessBeanDefinitionRegistry以及postProcessBeanFactory. invokeBeanFactoryPostProcessors(beanFactory); // 注册BeanPostProcessor（Bean的后置处理器）. registerBeanPostProcessors(beanFactory); // 初始化信息源，国际化. initMessageSource(); // 初始化Spring的事件广播器. initApplicationEventMulticaster(); // 模板方法，子上下文创建Bean. onRefresh(); registerListeners(); // 实例化所有剩余的（非懒加载）单例Bean，BeanPostProcessor开始起作用. finishBeanFactoryInitialization(beanFactory); finishRefresh(); &#125; catch (BeansException ex) &#123; // Destroy already created singletons to avoid dangling resources. destroyBeans(); throw ex; &#125; &#125; &#125; 准备阶段准备阶段只有一个方法prepareRefresh。 prepareRefreshprotected void prepareRefresh() &#123; // ① 一些标识类动作 this.startupDate = System.currentTimeMillis(); this.closed.set(false); this.active.set(true); // ② 初始化 Environment 以及关联的 PropertySource // 子类实现，如servlet web环境的GenericWebApplicationContext。 initPropertySources(); // ③ 校验 Environment 必备属性 // see ConfigurablePropertyResolver#setRequiredProperties getEnvironment().validateRequiredProperties(); // ④ 初始化事件监听器集合 if (this.earlyApplicationListeners == null) &#123; this.earlyApplicationListeners = new LinkedHashSet&lt;>(this.applicationListeners); &#125; else &#123; // Reset local application listeners to pre-refresh state. this.applicationListeners.clear(); this.applicationListeners.addAll(this.earlyApplicationListeners); &#125; // ⑤ 初始化早期的 Spring 事件集合 this.earlyApplicationEvents = new LinkedHashSet&lt;>(); &#125; BeanFactory 级别处理阶段ApplicationContext 接口虽然实现了 BeanFactory，实际更像是一个代理类，底层的 IOC 容器还是 BeanFactory。BeanFactory 级别处理阶段包含三个阶段：获取 BeanFactory、准备 BeanFactory、执行BeanFactoryPostProcessors。 obtainFreshBeanFactory获取 BeanFactory 分为两部分：刷新 BeanFactory 和返回 BeanFactory（默认是 DefaultListableBeanFactory）。 protected ConfigurableListableBeanFactory obtainFreshBeanFactory() &#123; // 刷新底层的BeanFactory refreshBeanFactory(); return getBeanFactory(); &#125; 一般为GenericWebApplicationContext，只是简单的设置 FactoryId 而已。 protected final void refreshBeanFactory() throws IllegalStateException &#123; this.beanFactory.setSerializationId(getId()); &#125; prepareBeanFactory创建完 BeanFactory，会对其进行一些准备工作：包括 ClassLoader、EL 表达式处理器、PropertyEditorRegistrar类型转换器、一些BeanPostProcesser以及一些环境变量 相关的单例对象。 protected void prepareBeanFactory(ConfigurableListableBeanFactory beanFactory) &#123; // 设置 ClassLoader beanFactory.setBeanClassLoader(getClassLoader()); // 设置 EL 表达式处理器 beanFactory.setBeanExpressionResolver(new StandardBeanExpressionResolver(beanFactory.getBeanClassLoader())); // 设置 PropertyEditorRegistrar 进行类型转换 beanFactory.addPropertyEditorRegistrar(new ResourceEditorRegistrar(this, getEnvironment())); // 添加 ApplicationContextAwareProcessor 处理器 // 会在AbstractAutowireCapableBeanFactory#initializeBean中执行 beanFactory.addBeanPostProcessor(new ApplicationContextAwareProcessor(this)); beanFactory.ignoreDependencyInterface(EnvironmentAware.class); beanFactory.ignoreDependencyInterface(EmbeddedValueResolverAware.class); beanFactory.ignoreDependencyInterface(ResourceLoaderAware.class); beanFactory.ignoreDependencyInterface(ApplicationEventPublisherAware.class); beanFactory.ignoreDependencyInterface(MessageSourceAware.class); beanFactory.ignoreDependencyInterface(ApplicationContextAware.class); // 注册一些内置的特殊依赖 beanFactory.registerResolvableDependency(BeanFactory.class, beanFactory); beanFactory.registerResolvableDependency(ResourceLoader.class, this); beanFactory.registerResolvableDependency(ApplicationEventPublisher.class, this); beanFactory.registerResolvableDependency(ApplicationContext.class, this); // 注册ApplicationListenerDetector用来探测ApplicationListener并添加至ApplicationContext beanFactory.addBeanPostProcessor(new ApplicationListenerDetector(this)); // Detect a LoadTimeWeaver and prepare for weaving, if found. if (beanFactory.containsBean(LOAD_TIME_WEAVER_BEAN_NAME)) &#123; beanFactory.addBeanPostProcessor(new LoadTimeWeaverAwareProcessor(beanFactory)); // Set a temporary ClassLoader for type matching. beanFactory.setTempClassLoader(new ContextTypeMatchClassLoader(beanFactory.getBeanClassLoader())); &#125; // 注册一些单例对象 Environment、java 环境变量和 OS 环境变量 if (!beanFactory.containsLocalBean(ENVIRONMENT_BEAN_NAME)) &#123; beanFactory.registerSingleton(ENVIRONMENT_BEAN_NAME, getEnvironment()); &#125; if (!beanFactory.containsLocalBean(SYSTEM_PROPERTIES_BEAN_NAME)) &#123; beanFactory.registerSingleton(SYSTEM_PROPERTIES_BEAN_NAME, getEnvironment().getSystemProperties()); &#125; if (!beanFactory.containsLocalBean(SYSTEM_ENVIRONMENT_BEAN_NAME)) &#123; beanFactory.registerSingleton(SYSTEM_ENVIRONMENT_BEAN_NAME, getEnvironment().getSystemEnvironment()); &#125; &#125; postProcessBeanFactorypostProcessBeanFactory是一种以继承方式的扩展。在Servlet环境下，注册WebApplicationContextServletContext回调处理器以及一些Scope。 // AnnotationConfigServletWebServerApplicationContext#postProcessBeanFactory protected void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) &#123; // 注册WebApplicationContextServletContextAwareProcessor以及一些Scope super.postProcessBeanFactory(beanFactory); // 扫描和注册 if (this.basePackages != null &amp;&amp; this.basePackages.length > 0) &#123; this.scanner.scan(this.basePackages); &#125; if (!this.annotatedClasses.isEmpty()) &#123; this.reader.register(ClassUtils.toClassArray(this.annotatedClasses)); &#125; &#125; invokeBeanFactoryPostProcessorsinvokeBeanFactoryPostProcessors与postProcessBeanFactory类似，也是一种 BeanFactory 的后置处理扩展。 区别是以组合的方式扩展。 // AbstractApplicationContext#invokeBeanFactoryPostProcessors protected void invokeBeanFactoryPostProcessors(ConfigurableListableBeanFactory beanFactory) &#123; // 通过 PostProcessorRegistrationDelegate 代理统一执行BeanFactoryPostProcessor(BeanDefinitionRegistry)Ò // 执行顺序 PriorityOrdered, Ordered, and the rest. PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors(beanFactory, getBeanFactoryPostProcessors()); &#125; ConfigurationClassPostProcessor是一个比较重要的ConfigurationClassPostProcessor，可以参考(三) ConfigurationClassPostProcessor。 Bean 级别处理阶段Bean 级别处理阶段包括4大部分：注册BeanPostProcessor、初始化内置组件（国际化和事件广播器）、 registerBeanPostProcessorsregisterBeanPostProcessors会按照PriorityOrdered（先初始化）、Ordered、普通BeanPostProcessor顺序注册、MergedBeanDefinitionPostProcessor（先初始化）顺序注册，并将ApplicationListenerDetector移至末尾。 // PostProcessorRegistrationDelegate#registerBeanPostProcessors public static void registerBeanPostProcessors( ConfigurableListableBeanFactory beanFactory, AbstractApplicationContext applicationContext) &#123; String[] postProcessorNames = beanFactory.getBeanNamesForType(BeanPostProcessor.class, true, false); // 存放实现PriorityOrdered接口的BeanPostProcessors，需提前初始化 List&lt;BeanPostProcessor> priorityOrderedPostProcessors = new ArrayList&lt;>(); // 存放MergedBeanDefinitionPostProcessor，需提前初始化 List&lt;BeanPostProcessor> internalPostProcessors = new ArrayList&lt;>(); // 存放实现Ordered接口的BeanPostProcessor List&lt;String> orderedPostProcessorNames = new ArrayList&lt;>(); // 存放普通BeanPostProcessor List&lt;String> nonOrderedPostProcessorNames = new ArrayList&lt;>(); for (String ppName : postProcessorNames) &#123; if (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) &#123; BeanPostProcessor pp = beanFactory.getBean(ppName, BeanPostProcessor.class); priorityOrderedPostProcessors.add(pp); if (pp instanceof MergedBeanDefinitionPostProcessor) &#123; internalPostProcessors.add(pp); &#125; &#125; else if (beanFactory.isTypeMatch(ppName, Ordered.class)) &#123; orderedPostProcessorNames.add(ppName); &#125; else &#123; nonOrderedPostProcessorNames.add(ppName); &#125; &#125; // 注册实现 PriorityOrdered 的 BeanPostProcessor // 先排序，后添加至beanFactory.beanPostProcessors尾部 sortPostProcessors(priorityOrderedPostProcessors, beanFactory); registerBeanPostProcessors(beanFactory, priorityOrderedPostProcessors); // 注册实现 Ordered 的 BeanPostProcessor List&lt;BeanPostProcessor> orderedPostProcessors = new ArrayList&lt;>(orderedPostProcessorNames.size()); ..... // 注册普通的 BeanPostProcessor List&lt;BeanPostProcessor> nonOrderedPostProcessors = new ArrayList&lt;>(nonOrderedPostProcessorNames.size()); ..... // 最后注册 MergedBeanDefinitionPostProcessor sortPostProcessors(internalPostProcessors, beanFactory); registerBeanPostProcessors(beanFactory, internalPostProcessors); // 重新注册ApplicationListenerDetector，移至末尾 beanFactory.addBeanPostProcessor(new ApplicationListenerDetector(applicationContext)); &#125; initMessageSource略 initApplicationEventMulticaster略 onRefreshonRefresh是一个钩子方法，需要Web环境子类实现。 // ServletWebServerApplicationContext#onRefresh protected void onRefresh() &#123; super.onRefresh(); try &#123; createWebServer(); &#125; &#125; theme 是指页面的CSS、图片、国际化等资源的集合 // GenericWebApplicationContext#onRefresh protected void onRefresh() &#123; this.themeSource = UiApplicationContextUtils.initThemeSource(this); &#125; private void createWebServer() &#123; WebServer webServer = this.webServer; ServletContext servletContext = getServletContext(); if (webServer == null &amp;&amp; servletContext == null) &#123; ServletWebServerFactory factory = getWebServerFactory(); this.webServer = factory.getWebServer(getSelfInitializer()); getBeanFactory().registerSingleton(\"webServerGracefulShutdown\", new WebServerGracefulShutdownLifecycle(this.webServer)); getBeanFactory().registerSingleton(\"webServerStartStop\", new WebServerStartStopLifecycle(this, this.webServer)); &#125; else if (servletContext != null) &#123; try &#123; getSelfInitializer().onStartup(servletContext); &#125; &#125; initPropertySources(); &#125; 查找ServletWebServerFactory，包含TomcatServletWebServerFactory，JettyServletWebServerFactory、UndertowServletWebServerFactory。 所以我们如果要使用UndertowServletWebServer就需要先排除 Tomcat 的依赖，然后直接添加 Undertow 的依赖即可 protected ServletWebServerFactory getWebServerFactory() &#123; String[] beanNames = getBeanFactory().getBeanNamesForType(ServletWebServerFactory.class); return getBeanFactory().getBean(beanNames[0], ServletWebServerFactory.class); &#125; registerListenersregisterListeners会获取手动注册在当前上下文的以及配置的ApplicationListener，同时发布earlyApplicationEvents。 protected void registerListeners() &#123; // 把手动注册的监听器绑定到广播器 for (ApplicationListener&lt;?> listener : getApplicationListeners()) &#123; getApplicationEventMulticaster().addApplicationListener(listener); &#125; // 取到容器里面的所有的监听器的名称，绑定到广播器 // uninitialized to let post-processors apply to them! String[] listenerBeanNames = getBeanNamesForType(ApplicationListener.class, true, false); for (String listenerBeanName : listenerBeanNames) &#123; getApplicationEventMulticaster().addApplicationListenerBean(listenerBeanName); &#125; // 发布earlyApplicationEvents Set&lt;ApplicationEvent> earlyEventsToProcess = this.earlyApplicationEvents; this.earlyApplicationEvents = null; if (!CollectionUtils.isEmpty(earlyEventsToProcess)) &#123; for (ApplicationEvent earlyEvent : earlyEventsToProcess) &#123; getApplicationEventMulticaster().multicastEvent(earlyEvent); &#125; &#125; &#125; finishBeanFactoryInitialization实例化所有剩余的（非懒加载）单例Bean。比如invokeBeanFactoryPostProcessors方法中根据各种注解解析出来的类，在这个时候都会被初始化扫描的@Bean之类的。实例化的过程各种BeanPostProcessor开始起作用。 protected void finishBeanFactoryInitialization(ConfigurableListableBeanFactory beanFactory) &#123; // 如果存在ConversionService，关联至BeanFactory if (beanFactory.containsBean(CONVERSION_SERVICE_BEAN_NAME) &amp;&amp; beanFactory.isTypeMatch(CONVERSION_SERVICE_BEAN_NAME, ConversionService.class)) &#123; beanFactory.setConversionService( beanFactory.getBean(CONVERSION_SERVICE_BEAN_NAME, ConversionService.class)); &#125; // PropertyPlaceholderAutoConfiguration 会自动注册 PropertySourcesPlaceholderConfigurer // 这里不会进 if (!beanFactory.hasEmbeddedValueResolver()) &#123; beanFactory.addEmbeddedValueResolver(strVal -> getEnvironment().resolvePlaceholders(strVal)); &#125; // 查找初始化 LoadTimeWeaverAware String[] weaverAwareNames = beanFactory.getBeanNamesForType(LoadTimeWeaverAware.class, false, false); for (String weaverAwareName : weaverAwareNames) &#123; getBean(weaverAwareName); &#125; // 临时的ClassLoader用于AOP beanFactory.setTempClassLoader(null); // 冻结配置 beanFactory.freezeConfiguration(); // 初始化所有非懒加载的Bean beanFactory.preInstantiateSingletons(); &#125; preInstantiateSingletons会区分 FactoryBean，核心是getBean方法。详情可以参考前面的(五) 依赖查找和(六) 循环依赖。最后还会触发SmartInitializingSingleton#afterSingletonsInstantiated 回调。 public void preInstantiateSingletons() throws BeansException &#123; List&lt;String> beanNames = new ArrayList&lt;>(this.beanDefinitionNames); // 通过 getBean 获取所有非懒加载的Bean for (String beanName : beanNames) &#123; // 获取合并后的 RootBeanDefinition RootBeanDefinition bd = getMergedLocalBeanDefinition(beanName); if (!bd.isAbstract() &amp;&amp; bd.isSingleton() &amp;&amp; !bd.isLazyInit()) &#123; if (isFactoryBean(beanName)) &#123; // 如果是工厂类，加一个“&amp;”前缀 Object bean = getBean(FACTORY_BEAN_PREFIX + beanName); if (bean instanceof FactoryBean) &#123; FactoryBean&lt;?> factory = (FactoryBean&lt;?>) bean; boolean isEagerInit; if (System.getSecurityManager() != null &amp;&amp; factory instanceof SmartFactoryBean) &#123; isEagerInit = AccessController.doPrivileged( (PrivilegedAction&lt;Boolean>) ((SmartFactoryBean&lt;?>) factory)::isEagerInit, getAccessControlContext()); &#125; else &#123; isEagerInit = (factory instanceof SmartFactoryBean &amp;&amp; ((SmartFactoryBean&lt;?>) factory).isEagerInit()); &#125; if (isEagerInit) &#123; getBean(beanName); &#125; &#125; &#125; else &#123; getBean(beanName); &#125; &#125; &#125; // 触发 SmartInitializingSingleton#afterSingletonsInstantiated 回调 for (String beanName : beanNames) &#123; Object singletonInstance = getSingleton(beanName); if (singletonInstance instanceof SmartInitializingSingleton) &#123; SmartInitializingSingleton smartSingleton = (SmartInitializingSingleton) singletonInstance; if (System.getSecurityManager() != null) &#123; AccessController.doPrivileged((PrivilegedAction&lt;Object>) () -> &#123; smartSingleton.afterSingletonsInstantiated(); return null; &#125;, getAccessControlContext()); &#125; else &#123; smartSingleton.afterSingletonsInstantiated(); &#125; &#125; &#125; &#125; 结束阶段结束阶段只有一个方法入口：finishRefresh finishRefreshprotected void finishRefresh() &#123; clearResourceCaches(); // Lifecycle 中包含start/stop方法，实现此接口后Spring会保证在启动的时候调用其start方法开始生命周期 // 并在Spring关闭的时候调用 stop方法来结束生命周期， // 通常用来配置后台程序，在启动后一直运行（如对 kafka 进行轮询等）。 initLifecycleProcessor(); //通过 lifecycle processor 触发 SmartLifecycle 执行 getLifecycleProcessor().onRefresh(); // 发布 ContextRefreshedEvent publishEvent(new ContextRefreshedEvent(this)); // 对 MBean 的支持 LiveBeansView.registerApplicationContext(this); &#125; initLifecycleProcessor 会创建一个DefaultLifecycleProcessor来执行负责Lifecycle。 protected void initLifecycleProcessor() &#123; ConfigurableListableBeanFactory beanFactory = getBeanFactory(); if (beanFactory.containsLocalBean(LIFECYCLE_PROCESSOR_BEAN_NAME)) &#123; // LifecycleAutoConfiguration 会自己注册 DefaultLifecycleProcessor this.lifecycleProcessor = beanFactory.getBean(LIFECYCLE_PROCESSOR_BEAN_NAME, LifecycleProcessor.class); &#125; else &#123; // 如果没有LifecycleProcessor就初始化DefaultLifecycleProcessor DefaultLifecycleProcessor defaultProcessor = new DefaultLifecycleProcessor(); defaultProcessor.setBeanFactory(beanFactory); this.lifecycleProcessor = defaultProcessor; beanFactory.registerSingleton(LIFECYCLE_PROCESSOR_BEAN_NAME, this.lifecycleProcessor); &#125; &#125; LifecycleProcessor#onRefresh只会触发SmartLifecycle，Lifecycle需要显示调用start。 // DefaultLifecycleProcessor#startBeans private void startBeans(boolean autoStartupOnly) &#123; Map&lt;String, Lifecycle> lifecycleBeans = getLifecycleBeans(); Map&lt;Integer, LifecycleGroup> phases = new HashMap&lt;>(); lifecycleBeans.forEach((beanName, bean) -> &#123; // autoStartupOnly == true // 只有SmartLifecycle才会在refresh中执行start方法 if (!autoStartupOnly || (bean instanceof SmartLifecycle &amp;&amp; ((SmartLifecycle) bean).isAutoStartup())) &#123; int phase = getPhase(bean); LifecycleGroup group = phases.get(phase); if (group == null) &#123; group = new LifecycleGroup(phase, this.timeoutPerShutdownPhase, lifecycleBeans, autoStartupOnly); phases.put(phase, group); &#125; group.add(beanName, bean); &#125; &#125;); if (!phases.isEmpty()) &#123; List&lt;Integer> keys = new ArrayList&lt;>(phases.keySet()); Collections.sort(keys); for (Integer key : keys) &#123; // phase 越小越靠前执行 phases.get(key).start(); &#125; &#125; &#125; 如果是 servlet 环境，会添加WebServerStartStopLifecycle和WebServerGracefulShutdownLifecycle两个SmartLifecycle。 // WebServerStartStopLifecycle#start public void start() &#123; this.webServer.start(); this.running = true; this.applicationContext .publishEvent(new ServletWebServerInitializedEvent(this.webServer, this.applicationContext)); &#125; Lifecycle 与 SmartLifecycle Lifecycle 中包含start/stop方法，会在应用上下文中显式调用 start/stop 时触发。通常用来配置后台程序，在启动后一直运行（如对 kafka 进行轮询等）。SmartLifecycle可以在 refresh 方法中触发，同时实现了Phased接口，以为可以根据getPhase进行排序执行。并且 stop 方法是异步支持回调。LifecycleProcessor作为Lifecycle的执行器，本身也实现了Lifecycle。同时 onfresh 方法也会在 fresh中被手动执行。 总结Spring Framework 中有多个扩展点： 模板方法 事件机制 各种BeanFactoryPostProcessors、BeanPostProcessors配合 SPI SmartInitializingSingleton SmartLifecycle","categories":[{"name":"主流框架","slug":"主流框架","permalink":"http://www.niceczj.online/categories/%E4%B8%BB%E6%B5%81%E6%A1%86%E6%9E%B6/"},{"name":"Spring","slug":"主流框架/Spring","permalink":"http://www.niceczj.online/categories/%E4%B8%BB%E6%B5%81%E6%A1%86%E6%9E%B6/Spring/"},{"name":"Spring Framework","slug":"主流框架/Spring/Spring-Framework","permalink":"http://www.niceczj.online/categories/%E4%B8%BB%E6%B5%81%E6%A1%86%E6%9E%B6/Spring/Spring-Framework/"}],"tags":[]},{"title":"(六) 循环依赖","slug":"六-循环依赖","date":"2020-11-08T14:36:09.000Z","updated":"2020-11-08T14:36:09.337Z","comments":true,"path":"2020/11/08/六-循环依赖/","link":"","permalink":"http://www.niceczj.online/2020/11/08/%E5%85%AD-%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96/","excerpt":"前面创建 Bean 的过程基本分为三步：实例化、属性填充、执行初始化方法。在填充属性进行依赖注入时，时会遇到一个特殊情况，就是循环依赖。前一章(五) 依赖查找为了突出主线 Bean 的实例化与初始化过程，故意省略了部分步骤。这篇将会分析 Spring Framework 是如何处理部分循环依赖的。","text":"前面创建 Bean 的过程基本分为三步：实例化、属性填充、执行初始化方法。在填充属性进行依赖注入时，时会遇到一个特殊情况，就是循环依赖。前一章(五) 依赖查找为了突出主线 Bean 的实例化与初始化过程，故意省略了部分步骤。这篇将会分析 Spring Framework 是如何处理部分循环依赖的。 三级缓存在DefaultSingletonBeanRegistry中有三个 Map 缓存，这三个缓存是解决循环依赖的关键。 public class DefaultSingletonBeanRegistry extends SimpleAliasRegistry implements SingletonBeanRegistry &#123; /** 一级缓存，存放实例且初始化后的实例对象 */ private final Map&lt;String, Object> singletonObjects = new ConcurrentHashMap&lt;>(256); /** 三级缓存，存放创建Bean的ObjectFactory */ private final Map&lt;String, ObjectFactory&lt;?>> singletonFactories = new HashMap&lt;>(16); /** 二级缓存，仅仅实例化的半成品对象 */ private final Map&lt;String, Object> earlySingletonObjects = new HashMap&lt;>(16); &#125; 假设有 A &lt;–&gt; B 相互依赖。我们在回顾下getBean的过程，看下三级缓存是如何生效的。 getSingleton(String, boolean)第一次DefaultSingletonBeanRegistry#getSingleton的逻辑梳理如下： 尝试从一级缓存获取 如果没有拿到且被标记正在创建，也就是陷入了循环 尝试从二级缓存获取已实例但未初始化的对象 如果还没获取，尝试从三级缓存中拿到ObjectFactory，并通过其getObject创建半成品对象放入二级缓存，同时移除三级缓存。 这个步骤很重要，第一次实例化A和B时，都是没有任何缓存的，但是下一步A重新进入该方法时，会拿到后面存的ObjectFactory(getEarlyBeanReference)创建一个半成品对象放入二级缓存，此时B仍然只在三级缓存中。 // DefaultSingletonBeanRegistry#getSingleton(java.lang.String, boolean) protected Object getSingleton(String beanName, boolean allowEarlyReference) &#123; // 一级缓存 Object singletonObject = this.singletonObjects.get(beanName); // 第一次进入时没有标记正在创建，所以会直接退出 if (singletonObject == null &amp;&amp; isSingletonCurrentlyInCreation(beanName)) &#123; // 后面`DefaultSingletonBeanRegistry#getSingleton(String, .ObjectFactory&lt;?>)`会标记 // 所以循环依赖后，第二次会进入 synchronized (this.singletonObjects) &#123; singletonObject = this.earlySingletonObjects.get(beanName); if (singletonObject == null &amp;&amp; allowEarlyReference) &#123; ObjectFactory&lt;?> singletonFactory = this.singletonFactories.get(beanName); if (singletonFactory != null) &#123; // AbstractAutowireCapableBeanFactory#getEarlyBeanReference // 如果有必要，会创建AOP代理（`AbstractAutoProxyCreator`） singletonObject = singletonFactory.getObject(); // 创建earlySingletonObject后放入二级缓存中，并移除三级缓存 this.earlySingletonObjects.put(beanName, singletonObject); this.singletonFactories.remove(beanName); &#125; &#125; &#125; &#125; return singletonObject; &#125; getSingleton(String, ObjectFactory&lt;?&gt;)第二个DefaultSingletonBeanRegistry#getSingleton重载 添加正在创建的标记 通过AbstractAutowireCapableBeanFactory#createBean创建实例 移除正在创建的标记 加入一级缓存，移除二三级缓存 A和B第二次进入这个方法，都会保证他们只存在一级缓存。 public Object getSingleton(String beanName, ObjectFactory&lt;?> singletonFactory) &#123; synchronized (this.singletonObjects) &#123; Object singletonObject = this.singletonObjects.get(beanName); if (singletonObject == null) &#123; // 这次再取不到就放入singletonsCurrentlyInCreation标记正在创建 beforeSingletonCreation(beanName); try &#123; // 通过`AbstractAutowireCapableBeanFactory#createBean`创建实例 singletonObject = singletonFactory.getObject(); newSingleton = true; &#125; finally &#123; // 移除singletonsCurrentlyInCreation标记 afterSingletonCreation(beanName); &#125; if (newSingleton) &#123; /** * this.singletonObjects.put(beanName, singletonObject); * this.singletonFactories.remove(beanName); * this.earlySingletonObjects.remove(beanName); */ addSingleton(beanName, singletonObject); &#125; &#125; return singletonObject; &#125; &#125; doCreateBeandoCreateBean开始增加一个匿名ObjectFactory，他的getObject方法是通过SmartInstantiationAwareBeanPostProcessor#getEarlyBeanReference返回半成品实例，一般只有AbstractAutoProxyCreator可能会创建一个AOP代理 // AbstractAutowireCapableBeanFactory#doCreateBean protected Object doCreateBean(String beanName, RootBeanDefinition mbd, @Nullable Object[] args) throws BeanCreationException &#123; ...... // 进行半成品实例的暴露 boolean earlySingletonExposure = (mbd.isSingleton() &amp;&amp; this.allowCircularReferences &amp;&amp; isSingletonCurrentlyInCreation(beanName)); if (earlySingletonExposure) &#123; /** * 三级缓存放入ObjectFactory，移除二级早期引用缓存 * this.singletonFactories.put(beanName, singletonFactory); * this.earlySingletonObjects.remove(beanName); * this.registeredSingletons.add(beanName); */ // getEarlyBeanReference：SmartInstantiationAwareBeanPostProcessor#getEarlyBeanReference // AbstractAutoProxyCreator#getEarlyBeanReference 会创建代理 addSingletonFactory(beanName, () -> getEarlyBeanReference(beanName, mbd, bean)); &#125; ...... return exposedObject; &#125; 剩下populateBean填充属性，AutowiredAnnotationBeanPostProcessor注入就不详细说了。 总结 创建A时，doCreateBean会添加getEarlyBeanReference至三级缓存中。下一步populateBean填充属性时，AutowiredAnnotationBeanPostProcessor会尝试注入B。此时A只在三级缓存中。 尝试创建B，与第一步一致。此时B只在三级缓存中。 再次回到创建A，此时getSingleton(String, boolean)会拿到getEarlyBeanReference，返回只实例化的A（如果有 AOP 会被AbstractAutoProxyCreator创建代理），并添加至二级缓存中。此时A只存在二级缓存中。 B通过doResolveDependency拿到A，通过反射注入并完成初始化。并通过addSingleton将B存到一级缓存中。此时B只存在一级缓存，A还在二级缓存中。 然后ApopulateBean会成功注入B，并通过addSingleton将A存到一级缓存中。此时A、B都已存在了一级缓存中。","categories":[{"name":"主流框架","slug":"主流框架","permalink":"http://www.niceczj.online/categories/%E4%B8%BB%E6%B5%81%E6%A1%86%E6%9E%B6/"},{"name":"Spring","slug":"主流框架/Spring","permalink":"http://www.niceczj.online/categories/%E4%B8%BB%E6%B5%81%E6%A1%86%E6%9E%B6/Spring/"},{"name":"Spring Framework","slug":"主流框架/Spring/Spring-Framework","permalink":"http://www.niceczj.online/categories/%E4%B8%BB%E6%B5%81%E6%A1%86%E6%9E%B6/Spring/Spring-Framework/"}],"tags":[]},{"title":"(五) 依赖查找","slug":"五-依赖查找","date":"2020-11-08T14:35:55.000Z","updated":"2020-11-08T14:35:55.284Z","comments":true,"path":"2020/11/08/五-依赖查找/","link":"","permalink":"http://www.niceczj.online/2020/11/08/%E4%BA%94-%E4%BE%9D%E8%B5%96%E6%9F%A5%E6%89%BE/","excerpt":"Spring 中通过AbstractBeanFactory#getBean来查找 Bean。这个方法牵扯到 Bean 的实例化以及初始化。一般有三个场景会触发到该方法： refresh步骤中的finishBeanFactoryInitialization会实例化非懒加载的Bean； 被依赖注入； 直接执行底层 API：AbstractBeanFactory#getBean。比如项目中我们通常会继承ApplicationContextAware来编写一个可以查找 Bean 的工具类。","text":"Spring 中通过AbstractBeanFactory#getBean来查找 Bean。这个方法牵扯到 Bean 的实例化以及初始化。一般有三个场景会触发到该方法： refresh步骤中的finishBeanFactoryInitialization会实例化非懒加载的Bean； 被依赖注入； 直接执行底层 API：AbstractBeanFactory#getBean。比如项目中我们通常会继承ApplicationContextAware来编写一个可以查找 Bean 的工具类。 getBeanAbstractBeanFactory#GetBean是底层获取 Bean 实例的 API 入口，我们可以通过跟踪其代码： 从DefaultSingletonBeanRegistry#getSingleton(String, boolean)缓存尝试获取实例 如果能从缓存获取 实例且是FactoryBean，则调用getObject方法获取实例 如果不能从缓存获取 如果有父 BeanFactory 且不存在 BeanDefinition。调用父工厂getBean 获取合并 beanDefinition 后的 RootBeanDefinition 如果有 dependsOn，先取依赖的实例对象 根据 scope 进行不同处理 如果是单例，使用AbstractAutowireCapableBeanFactory#createBean创建实例 最终尝试进行类型转换 // AbstractBeanFactory#doGetBean protected &lt;T> T doGetBean( String name, @Nullable Class&lt;T> requiredType, @Nullable Object[] args, boolean typeCheckOnly) throws BeansException &#123; // 对 FactoryBean 或者别名映射进行处理 String beanName = transformedBeanName(name); Object bean; // 从缓存获取实例（最开始从实例缓存） Object sharedInstance = getSingleton(beanName); if (sharedInstance != null &amp;&amp; args == null) &#123; // 如果从缓存中拿到的是`FactoryBean`，则调用`getObject`方法获取实例 bean = getObjectForBeanInstance(sharedInstance, name, beanName, null); &#125; else &#123; BeanFactory parentBeanFactory = getParentBeanFactory(); if (parentBeanFactory != null &amp;&amp; !containsBeanDefinition(beanName)) &#123; // 如果有父BeanFactory且不存在BeanDefinition。调用父工厂getBean ...... &#125; try &#123; // 获取合并beanDefinition后的RootBeanDefinition RootBeanDefinition mbd = getMergedLocalBeanDefinition(beanName); // 如果有dependsOn，先取依赖的实例对象 String[] dependsOn = mbd.getDependsOn(); if (dependsOn != null) &#123; for (String dep : dependsOn) &#123; registerDependentBean(dep, beanName); try &#123; getBean(dep); &#125; &#125; &#125; // 创建实例对象 if (mbd.isSingleton()) &#123; sharedInstance = getSingleton(beanName, () -> &#123; try &#123; // AbstractAutowireCapableBeanFactory#createBean return createBean(beanName, mbd, args); &#125; &#125;); // 如果能从缓存获取实例且是`FactoryBean`，则调用`getObject`方法获取实例 bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd); &#125; // 原型处理逻辑 else if (mbd.isPrototype()) &#123; Object prototypeInstance = null; try &#123; beforePrototypeCreation(beanName); prototypeInstance = createBean(beanName, mbd, args); &#125; finally &#123; afterPrototypeCreation(beanName); &#125; bean = getObjectForBeanInstance(prototypeInstance, name, beanName, mbd); &#125; // 其他scope else &#123; String scopeName = mbd.getScope(); Scope scope = this.scopes.get(scopeName); try &#123; Object scopedInstance = scope.get(beanName, () -> &#123; beforePrototypeCreation(beanName); try &#123; return createBean(beanName, mbd, args); &#125; finally &#123; afterPrototypeCreation(beanName); &#125; &#125;); bean = getObjectForBeanInstance(scopedInstance, name, beanName, mbd); &#125; &#125; &#125; &#125; // 最终尝试进行类型转换 if (requiredType != null &amp;&amp; !requiredType.isInstance(bean)) &#123; try &#123; T convertedBean = getTypeConverter().convertIfNecessary(bean, requiredType); return convertedBean; &#125; &#125; return (T) bean; &#125; createBeanAbstractAutowireCapableBeanFactory#createBean在真正执行doCreateBean前会给InstantiationAwareBeanPostProcessor#BeanPostProcessorsBeforeInstantiation执行的机会，如果该方向返回对象，还会执行InstantiationAwareBeanPostProcessor#BeanPostProcessorsAfterInstantiation //`AbstractAutowireCapableBeanFactory#createBean` protected Object createBean(String beanName, RootBeanDefinition mbd, @Nullable Object[] args) throws BeanCreationException &#123; ...... try &#123; // 给 InstantiationAwareBeanPostProcessors 执行实例化前后的钩子 Object bean = resolveBeforeInstantiation(beanName, mbdToUse); if (bean != null) &#123; return bean; &#125; &#125; try &#123; Object beanInstance = doCreateBean(beanName, mbdToUse, args); return beanInstance; &#125; &#125; resolveBeforeInstantiationAbstractAutowireCapableBeanFactory#resolveBeforeInstantiation会执行InstantiationAwareBeanPostProcessor的实例化前后钩子： // AbstractAutowireCapableBeanFactory#resolveBeforeInstantiation protected Object resolveBeforeInstantiation(String beanName, RootBeanDefinition mbd) &#123; Object bean = null; if (!Boolean.FALSE.equals(mbd.beforeInstantiationResolved)) &#123; if (!mbd.isSynthetic() &amp;&amp; hasInstantiationAwareBeanPostProcessors()) &#123; Class&lt;?> targetType = determineTargetType(beanName, mbd); if (targetType != null) &#123; bean = applyBeanPostProcessorsBeforeInstantiation(targetType, beanName); if (bean != null) &#123; // 如果返回对象，还会执行BeanPostProcessorsAfterInitialization bean = applyBeanPostProcessorsAfterInitialization(bean, beanName); &#125; &#125; &#125; mbd.beforeInstantiationResolved = (bean != null); &#125; return bean; &#125; doCreateBean 通过构造器进行实例化 执行MergedBeanDefinitionPostProcessor合并Bean定义 如果在循环依赖 ，修改缓存状态 populateBean填充属性 initializeBean初始化 // AbstractAutowireCapableBeanFactory#doCreateBean protected Object doCreateBean(String beanName, RootBeanDefinition mbd, @Nullable Object[] args) throws BeanCreationException &#123; BeanWrapper instanceWrapper = null; if (mbd.isSingleton()) &#123; instanceWrapper = this.factoryBeanInstanceCache.remove(beanName); &#125; if (instanceWrapper == null) &#123; // 通过构造函数实例化并包装成BeanWrapper // 如果没有重载方法，就通过无参构造器实例化（AbstractAutowireCapableBeanFactory#instantiateBean） instanceWrapper = createBeanInstance(beanName, mbd, args); &#125; Object bean = instanceWrapper.getWrappedInstance(); Class&lt;?> beanType = instanceWrapper.getWrappedClass(); if (beanType != NullBean.class) &#123; mbd.resolvedTargetType = beanType; &#125; // 执行MergedBeanDefinitionPostProcessor合并Bean定义 synchronized (mbd.postProcessingLock) &#123; if (!mbd.postProcessed) &#123; try &#123; applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName); &#125; mbd.postProcessed = true; &#125; &#125; // 进行半成品实例的暴露 boolean earlySingletonExposure = (mbd.isSingleton() &amp;&amp; this.allowCircularReferences &amp;&amp; isSingletonCurrentlyInCreation(beanName)); if (earlySingletonExposure) &#123; /** * 三级缓存放入ObjectFactory，移除二级早期引用缓存 * this.singletonFactories.put(beanName, singletonFactory); * this.earlySingletonObjects.remove(beanName); * this.registeredSingletons.add(beanName); */ // getEarlyBeanReference：SmartInstantiationAwareBeanPostProcessor#getEarlyBeanReference // AbstractAutoProxyCreator#getEarlyBeanReference 会创建代理 addSingletonFactory(beanName, () -> getEarlyBeanReference(beanName, mbd, bean)); &#125; Object exposedObject = bean; try &#123; // 开始填充属性 populateBean(beanName, mbd, instanceWrapper); exposedObject = initializeBean(beanName, exposedObject, mbd); &#125; if (earlySingletonExposure) &#123; // 只找到二级缓存 Object earlySingletonReference = getSingleton(beanName, false); if (earlySingletonReference != null) &#123; if (exposedObject == bean) &#123; exposedObject = earlySingletonReference; &#125; else if (!this.allowRawInjectionDespiteWrapping &amp;&amp; hasDependentBean(beanName)) &#123; String[] dependentBeans = getDependentBeans(beanName); Set&lt;String> actualDependentBeans = new LinkedHashSet&lt;>(dependentBeans.length); for (String dependentBean : dependentBeans) &#123; if (!removeSingletonIfCreatedForTypeCheckOnly(dependentBean)) &#123; actualDependentBeans.add(dependentBean); &#125; &#125; &#125; &#125; &#125; // Register bean as disposable. try &#123; registerDisposableBeanIfNecessary(beanName, bean, mbd); &#125; return exposedObject; &#125; populateBeanAbstractAutowireCapableBeanFactory#populateBean开始填充属性： 执行InstantiationAwareBeanPostProcessor#postProcessAfterInstantiation实例化后的钩子 如果 BeanDefinition 中的 AutowireMode 显式的修改了 byType or byName，则会进行自动注入 执行InstantiationAwareBeanPostProcessor#postProcessProperties进行属性值修改，如AutowiredAnnotationBeanPostProcessor // AbstractAutowireCapableBeanFactory#populateBean protected void populateBean(String beanName, RootBeanDefinition mbd, @Nullable BeanWrapper bw) &#123; // 执行InstantiationAwareBeanPostProcessor#postProcessAfterInstantiation实例化后的钩子 if (!mbd.isSynthetic() &amp;&amp; hasInstantiationAwareBeanPostProcessors()) &#123; for (BeanPostProcessor bp : getBeanPostProcessors()) &#123; if (bp instanceof InstantiationAwareBeanPostProcessor) &#123; InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor) bp; if (!ibp.postProcessAfterInstantiation(bw.getWrappedInstance(), beanName)) &#123; return; &#125; &#125; &#125; &#125; PropertyValues pvs = (mbd.hasPropertyValues() ? mbd.getPropertyValues() : null); // 如果BeanDefinition中的AutowireMode显式的修改了byType or byName，则会进行自动注入 // 一般不会自动注入，需要用注解或xml手动注入 int resolvedAutowireMode = mbd.getResolvedAutowireMode(); if (resolvedAutowireMode == AUTOWIRE_BY_NAME || resolvedAutowireMode == AUTOWIRE_BY_TYPE) &#123; MutablePropertyValues newPvs = new MutablePropertyValues(pvs); if (resolvedAutowireMode == AUTOWIRE_BY_NAME) &#123; autowireByName(beanName, mbd, bw, newPvs); &#125; if (resolvedAutowireMode == AUTOWIRE_BY_TYPE) &#123; autowireByType(beanName, mbd, bw, newPvs); &#125; pvs = newPvs; &#125; PropertyDescriptor[] filteredPds = null; if (hasInstAwareBpps) &#123; if (pvs == null) &#123; pvs = mbd.getPropertyValues(); &#125; for (BeanPostProcessor bp : getBeanPostProcessors()) &#123; if (bp instanceof InstantiationAwareBeanPostProcessor) &#123; InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor) bp; // 执行`InstantiationAwareBeanPostProcessor#postProcessProperties` // 如 AutowiredAnnotationBeanPostProcessor PropertyValues pvsToUse = ibp.postProcessProperties(pvs, bw.getWrappedInstance(), beanName); if (pvsToUse == null) &#123; pvsToUse = ibp.postProcessPropertyValues(pvs, filteredPds, bw.getWrappedInstance(), beanName); if (pvsToUse == null) &#123; return; &#125; &#125; pvs = pvsToUse; &#125; &#125; &#125; if (pvs != null) &#123; // 将所有 PropertyValues 中的属性填充到 BeanWrapper 中 applyPropertyValues(beanName, mbd, bw, pvs); &#125; &#125; postProcessPropertyValuesAutowiredAnnotationBeanPostProcessor#postProcessPropertyValues注入属性是通过DefaultListableBeanFactory#resolveDependency获取到被注入的对象，然后反射set进去。 如果是循环依赖了，DefaultListableBeanFactory#resolveDependency返回的是二级缓存中的半成品earlySingletonObject。 // AutowiredAnnotationBeanPostProcessor.AutowiredFieldElement#inject protected void inject(Object bean, @Nullable String beanName, @Nullable PropertyValues pvs) throws Throwable &#123; DependencyDescriptor desc = new DependencyDescriptor(field, this.required); desc.setContainingClass(bean.getClass()); Set&lt;String> autowiredBeanNames = new LinkedHashSet&lt;>(1); TypeConverter typeConverter = beanFactory.getTypeConverter(); try &#123; // DefaultListableBeanFactory#resolveDependency // 从 AbstractBeanFactory#getBean(java.lang.String) 拿被注入的实例 // 如果是循环依赖了,返回的是二级缓存中的半成品`earlySingletonObject`。 value = beanFactory.resolveDependency(desc, beanName, autowiredBeanNames, typeConverter); &#125; if (value != null) &#123; ReflectionUtils.makeAccessible(field); field.set(bean, value); &#125; &#125; &#125; getEarlyBeanReference在AbstractAutowireCapableBeanFactory#doCreateBean中会放入该方法：addSingletonFactory(beanName, () -&gt; getEarlyBeanReference(beanName, mbd, bean));。 AbstractAutowireCapableBeanFactory#getEarlyBeanReference会尝试执行SmartInstantiationAwareBeanPostProcessor#getEarlyBeanReference。 比较重要的一个SmartInstantiationAwareBeanPostProcessor是AbstractAutoProxyCreator，会通过getEarlyBeanReference创建一个 AOP 代理对象。 // AbstractAutowireCapableBeanFactory#getEarlyBeanReference protected Object getEarlyBeanReference(String beanName, RootBeanDefinition mbd, Object bean) &#123; Object exposedObject = bean; if (!mbd.isSynthetic() &amp;&amp; hasInstantiationAwareBeanPostProcessors()) &#123; for (BeanPostProcessor bp : getBeanPostProcessors()) &#123; if (bp instanceof SmartInstantiationAwareBeanPostProcessor) &#123; SmartInstantiationAwareBeanPostProcessor ibp = (SmartInstantiationAwareBeanPostProcessor) bp; exposedObject = ibp.getEarlyBeanReference(exposedObject, beanName); &#125; &#125; &#125; return exposedObject; &#125; initializeBeanAbstractAutowireCapableBeanFactory#initializeBean即给 Bean 初始化： 执行 aware 接口的回调方法 执行BeanPostProcessor#postProcessBeforeInitialization初始化前的钩子（@PostConstruct由CommonAnnotationBeanPostProcessor执行） 执行其他初始化方法，包括：InitializingBean#afterPropertiesSet和自定义init方法 执行BeanPostProcessor#postProcessAfterInitialization初始化前的钩子 protected Object initializeBean(String beanName, Object bean, @Nullable RootBeanDefinition mbd) &#123; if (System.getSecurityManager() != null) &#123; AccessController.doPrivileged((PrivilegedAction&lt;Object>) () -> &#123; invokeAwareMethods(beanName, bean); return null; &#125;, getAccessControlContext()); &#125; else &#123; // 执行 aware 接口的回调方法 invokeAwareMethods(beanName, bean); &#125; Object wrappedBean = bean; if (mbd == null || !mbd.isSynthetic()) &#123; // 执行`BeanPostProcessor#postProcessBeforeInitialization`初始化前的钩子 // `@PostConstruct`由`CommonAnnotationBeanPostProcessor`执行 wrappedBean = applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName); &#125; try &#123; // 执行其他初始化方法，包括：`InitializingBean#afterPropertiesSet`和自定义init方法 invokeInitMethods(beanName, wrappedBean, mbd); &#125; if (mbd == null || !mbd.isSynthetic()) &#123; // 执行`BeanPostProcessor#postProcessAfterInitialization`初始化后的钩子 wrappedBean = applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName); &#125; return wrappedBean; &#125; invokeAwareMethods AbstractAutowireCapableBeanFactory#invokeAwareMethods比较简单，就是对BeanNameAware、BeanClassLoaderAware、BeanFactoryAware 接口实现类执行对应的set方法。 private void invokeAwareMethods(String beanName, Object bean) &#123; if (bean instanceof Aware) &#123; if (bean instanceof BeanNameAware) &#123; ((BeanNameAware) bean).setBeanName(beanName); &#125; if (bean instanceof BeanClassLoaderAware) &#123; ClassLoader bcl = getBeanClassLoader(); if (bcl != null) &#123; ((BeanClassLoaderAware) bean).setBeanClassLoader(bcl); &#125; &#125; if (bean instanceof BeanFactoryAware) &#123; ((BeanFactoryAware) bean).setBeanFactory(AbstractAutowireCapableBeanFactory.this); &#125; &#125; &#125; invokeInitMethodsAbstractAutowireCapableBeanFactory#invokeInitMethods会依次执行InitializingBean#afterPropertiesSet和自定义的 init 方法。 // AbstractAutowireCapableBeanFactory#invokeInitMethods protected void invokeInitMethods(String beanName, Object bean, @Nullable RootBeanDefinition mbd) throws Throwable &#123; boolean isInitializingBean = (bean instanceof InitializingBean); if (isInitializingBean &amp;&amp; (mbd == null || !mbd.isExternallyManagedInitMethod(\"afterPropertiesSet\"))) &#123; if (System.getSecurityManager() != null) &#123; try &#123; AccessController.doPrivileged((PrivilegedExceptionAction&lt;Object>) () -> &#123; ((InitializingBean) bean).afterPropertiesSet(); return null; &#125;, getAccessControlContext()); &#125; catch (PrivilegedActionException pae) &#123; throw pae.getException(); &#125; &#125; else &#123; ((InitializingBean) bean).afterPropertiesSet(); &#125; &#125; if (mbd != null &amp;&amp; bean.getClass() != NullBean.class) &#123; String initMethodName = mbd.getInitMethodName(); if (StringUtils.hasLength(initMethodName) &amp;&amp; !(isInitializingBean &amp;&amp; \"afterPropertiesSet\".equals(initMethodName)) &amp;&amp; !mbd.isExternallyManagedInitMethod(initMethodName)) &#123; invokeCustomInitMethod(beanName, bean, mbd); &#125; &#125; &#125; 总结","categories":[{"name":"主流框架","slug":"主流框架","permalink":"http://www.niceczj.online/categories/%E4%B8%BB%E6%B5%81%E6%A1%86%E6%9E%B6/"},{"name":"Spring","slug":"主流框架/Spring","permalink":"http://www.niceczj.online/categories/%E4%B8%BB%E6%B5%81%E6%A1%86%E6%9E%B6/Spring/"},{"name":"Spring Framework","slug":"主流框架/Spring/Spring-Framework","permalink":"http://www.niceczj.online/categories/%E4%B8%BB%E6%B5%81%E6%A1%86%E6%9E%B6/Spring/Spring-Framework/"}],"tags":[]},{"title":"(四) Spring Event","slug":"四-Spring-Event","date":"2020-11-02T11:05:52.000Z","updated":"2020-11-02T11:05:52.152Z","comments":true,"path":"2020/11/02/四-Spring-Event/","link":"","permalink":"http://www.niceczj.online/2020/11/02/%E5%9B%9B-Spring-Event/","excerpt":"Spring 中大量使用到了事件驱动模式。在 Spring Boot 中，Spring Event 尤其重要。","text":"Spring 中大量使用到了事件驱动模式。在 Spring Boot 中，Spring Event 尤其重要。 Java EventJDK 中实现了一套基本的观察者模式。Spring Event 也遵循了该规范。这个模式有三个角色： public class ObserverDemo &#123; public static void main(String[] args) &#123; EventObservable observable = new EventObservable(); observable.addObserver(new EventObserver()); observable.notifyObservers(\"Hello World\"); &#125; /** * Observable 被观察者 */ static class EventObservable extends Observable &#123; @Override public void notifyObservers(Object arg) &#123; // Observable#notifyObservers 设置了一个 changed 标志位 setChanged(); super.notifyObservers(new EventObject(arg)); clearChanged(); &#125; &#125; /** * Observer 观察者 * EventListener 事件监听器 */ static class EventObserver implements Observer, EventListener &#123; @Override public void update(Observable o, Object event) &#123; EventObject eventObject = (EventObject) event; System.out.println(\"收到事件 ：\" + eventObject); &#125; &#125; &#125; Spring EventSpring 事件模型是对 JDK 的一种扩展，不同的是多了一个广播器角色： ApplicationEventPublisherApplicationEventPublisher只有一个实现ApplicationContext，所以 Spring 中的应用上下文即可以看做是事件发送者： public interface ApplicationContext extends EnvironmentCapable, ListableBeanFactory, HierarchicalBeanFactory, MessageSource, ApplicationEventPublisher, ResourcePatternResolver ApplicationEventApplicationEvent遵循了 JDK 规范，继承了EventObject： public abstract class ApplicationEvent extends EventObject Spring Framework 事件：在 Spring Framework 中，有4个应用上下文状态对应的事件： Spring Boot 事件在 Spring Boot 中，事件变的更加重要，涵盖了SpringApplication整个生命周期。在笔者的另一篇 Spring Boot 启动原理解析中有过总结： 名称 触发方法 说明 ApplicationStartingEvent starting 初始化SpringApplication后，准备Environment前 ApplicationEnvironmentPreparedEvent environmentPrepared 准备Environment后，创建上下文前 ApplicationContextInitializedEvent contextPrepared 创建上下文并设置执行完ApplicationContextInitializer后，上下文loadSource前 ApplicationPreparedEvent contextLoaded 上下文loadSource后，上下文refresh前 ApplicationStartedEvent started 上下文refresh后，回调callRunners前 ApplicationReadyEvent running 上下文完全启动 ApplicationFailedEvent failed SpringApplication启动失败会被catch，再触发此事件 ApplicationEventMulticaster发送事件实际上由ApplicationEventMulticaster完成。在AbstractApplicationContext#refresh中初始化ApplicationEventMulticaster，默认会创建一个SimpleApplicationEventMulticaster。 // AbstractApplicationContext#initApplicationEventMulticaster protected void initApplicationEventMulticaster() &#123; ConfigurableListableBeanFactory beanFactory = getBeanFactory(); if (beanFactory.containsLocalBean(APPLICATION_EVENT_MULTICASTER_BEAN_NAME)) &#123; this.applicationEventMulticaster = beanFactory.getBean(APPLICATION_EVENT_MULTICASTER_BEAN_NAME, ApplicationEventMulticaster.class); &#125; else &#123; // 如果没有 applicationEventMulticaster 就默认创建 SimpleApplicationEventMulticaster this.applicationEventMulticaster = new SimpleApplicationEventMulticaster(beanFactory); beanFactory.registerSingleton(APPLICATION_EVENT_MULTICASTER_BEAN_NAME, this.applicationEventMulticaster); &#125; &#125; // AbstractApplicationContext#publishEvent protected void publishEvent(Object event, @Nullable ResolvableType eventType) &#123; getApplicationEventMulticaster().multicastEvent(applicationEvent, eventType); &#125; SimpleApplicationEventMulticasterSimpleApplicationEventMulticaster是 Spring 中的默认实现。SimpleApplicationEventMulticaster 支持异步处理事件以及事件异常处理： public class SimpleApplicationEventMulticaster extends AbstractApplicationEventMulticaster &#123; @Nullable private Executor taskExecutor; @Nullable private ErrorHandler errorHandler; 异步发布在 Spring 中如果想异步发布事件一种方式是自定义一个SimpleApplicationEventMulticaster，但是会影响全局事件处理。 @Bean(name = AbstractApplicationContext.APPLICATION_EVENT_MULTICASTER_BEAN_NAME) public ApplicationEventMulticaster simpleApplicationEventMulticaster() &#123; SimpleApplicationEventMulticaster eventMulticaster = new SimpleApplicationEventMulticaster(); // 事件处理不需要安排大量线程 // 只要不阻塞当前线程即可 eventMulticaster.setTaskExecutor(Executors.newSingleThreadExecutor()); return eventMulticaster; &#125; 另一个直接使用 @Async+ @EventListener 或者@Async + ApplicationListener#onApplicationEvent，更加灵活。 ApplicationListenerApplicationListener同样遵循了 JDK 规范，实现了EventListener： @FunctionalInterface public interface ApplicationListener&lt;E extends ApplicationEvent> extends EventListener &#123; /** * Handle an application event. * @param event the event to respond to */ void onApplicationEvent(E event); &#125; 自定义ApplicationListener可以使用实现接口的方式，也可以使用注解@EventListener。 @EventListener 原理EventListenerMethodProcessor是@EventListener的处理器。如果在 Spring Boot 环境中，会在初始化AnnotationConfigServletWebServerApplicationContext#reader中注册。 // AnnotationConfigUtils#registerAnnotationConfigProcessors if (!registry.containsBeanDefinition(EVENT_LISTENER_PROCESSOR_BEAN_NAME)) &#123; RootBeanDefinition def = new RootBeanDefinition(EventListenerMethodProcessor.class); def.setSource(source); beanDefs.add(registerPostProcessor(registry, def, EVENT_LISTENER_PROCESSOR_BEAN_NAME)); &#125; EventListenerMethodProcessor实现了两个重要接口：SmartInitializingSingleton、BeanFactoryPostProcessor。 public class EventListenerMethodProcessor implements SmartInitializingSingleton, ApplicationContextAware, BeanFactoryPostProcessor postProcessBeanFactory按顺序先看BeanFactoryPostProcessor#postProcessBeanFactory，找出所有的EventListenerFactory： public void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) &#123; this.beanFactory = beanFactory; // 查询所有的 EventListenerFactory Map&lt;String, EventListenerFactory> beans = beanFactory.getBeansOfType(EventListenerFactory.class, false, false); List&lt;EventListenerFactory> factories = new ArrayList&lt;>(beans.values()); AnnotationAwareOrderComparator.sort(factories); this.eventListenerFactories = factories; &#125; EventListenerFactory有两个实现类，同时还有两个方法：supportsMethod匹配方法和createApplicationListener将对应的类名和方法构建成ApplicationListener。 afterSingletonsInstantiatedSmartInitializingSingleton#afterSingletonsInstantiated会在 refresh 最后一步beanFactory.preInstantiateSingletons()中最后执行。这一步会反射解析出标记@EventListener的方法，然后利用EventListenerFactory#createApplicationListener将其构造成ApplicationListenerMethodAdapter，并注册到上下文中。 public void afterSingletonsInstantiated() &#123; ConfigurableListableBeanFactory beanFactory = this.beanFactory; String[] beanNames = beanFactory.getBeanNamesForType(Object.class); for (String beanName : beanNames) &#123; if (!ScopedProxyUtils.isScopedTarget(beanName)) &#123; Class&lt;?> type = null; try &#123; type = AutoProxyUtils.determineTargetClass(beanFactory, beanName); &#125; // 如果是AOP代理类 if (type != null) &#123; if (ScopedObject.class.isAssignableFrom(type)) &#123; try &#123; // 获取原始类 Class&lt;?> targetClass = AutoProxyUtils.determineTargetClass( beanFactory, ScopedProxyUtils.getTargetBeanName(beanName)); if (targetClass != null) &#123; type = targetClass; &#125; &#125; &#125; try &#123; // 处理入口 processBean(beanName, type); &#125; &#125; &#125; &#125; &#125; private void processBean(final String beanName, final Class&lt;?> targetType) &#123; if (!this.nonAnnotatedClasses.contains(targetType) &amp;&amp; AnnotationUtils.isCandidateClass(targetType, EventListener.class) &amp;&amp; !isSpringContainerClass(targetType)) &#123; Map&lt;Method, EventListener> annotatedMethods = null; try &#123; // 反射解析出标记@EventListener 的方法 annotatedMethods = MethodIntrospector.selectMethods(targetType, (MethodIntrospector.MetadataLookup&lt;EventListener>) method -> AnnotatedElementUtils.findMergedAnnotation(method, EventListener.class)); &#125; if (CollectionUtils.isEmpty(annotatedMethods)) &#123; this.nonAnnotatedClasses.add(targetType); &#125; else &#123; ConfigurableApplicationContext context = this.applicationContext; List&lt;EventListenerFactory> factories = this.eventListenerFactories; for (Method method : annotatedMethods.keySet()) &#123; for (EventListenerFactory factory : factories) &#123; if (factory.supportsMethod(method)) &#123; Method methodToUse = AopUtils.selectInvocableMethod(method, context.getType(beanName)); // 利用`EventListenerFactory#createApplicationListener`将标记`@EventListener`的方法封装成`ApplicationListenerMethodAdapter` ApplicationListener&lt;?> applicationListener = factory.createApplicationListener(beanName, targetType, methodToUse); if (applicationListener instanceof ApplicationListenerMethodAdapter) &#123; ((ApplicationListenerMethodAdapter) applicationListener).init(context, this.evaluator); &#125; // 将创建的 ApplicationListenerMethodAdapter 注册到上下文中 context.addApplicationListener(applicationListener); break; &#125; &#125; &#125; &#125; &#125; &#125; 总结 JDK 观察者模式： Spring Event 模型： ApplicationContext实现了ApplicationEventPublisher, 所以 Spring 中的应用上下文即可以看做是事件发送者。 Spring Framework 有 Conetext 的 refresh、start、stop、close 事件；Spring Boot 中有SpringApplication生命周期中的各个事件节点。 SimpleApplicationEventMulticaster是AbstractApplicationEventMulticaster的默认实现，可以通过自定义SimpleApplicationEventMulticaster或者@Async进行事件异步处理。 @EventListener原理： EventListenerMethodProcessor是@EventListener的处理器 EventListenerMethodProcessor实现了BeanFactoryPostProcessor和SmartInitializingSingleton接口 BeanFactoryPostProcessor#postProcessBeanFactory：找出所有的EventListenerFactory。 SmartInitializingSingleton#afterSingletonsInstantiated：反射解析出标记@EventListener的方法，然后利用EventListenerFactory#createApplicationListener将其构造成ApplicationListenerMethodAdapter，并注册到上下文中。","categories":[{"name":"主流框架","slug":"主流框架","permalink":"http://www.niceczj.online/categories/%E4%B8%BB%E6%B5%81%E6%A1%86%E6%9E%B6/"},{"name":"Spring","slug":"主流框架/Spring","permalink":"http://www.niceczj.online/categories/%E4%B8%BB%E6%B5%81%E6%A1%86%E6%9E%B6/Spring/"},{"name":"Spring Framework","slug":"主流框架/Spring/Spring-Framework","permalink":"http://www.niceczj.online/categories/%E4%B8%BB%E6%B5%81%E6%A1%86%E6%9E%B6/Spring/Spring-Framework/"}],"tags":[]},{"title":"(三) ConfigurationClassPostProcessor","slug":"三-ConfigurationClassPostProcessor","date":"2020-11-02T06:25:45.000Z","updated":"2020-11-02T06:25:45.586Z","comments":true,"path":"2020/11/02/三-ConfigurationClassPostProcessor/","link":"","permalink":"http://www.niceczj.online/2020/11/02/%E4%B8%89-ConfigurationClassPostProcessor/","excerpt":"在前面(二) PostProcesser章节中提到过一个重要的BeanDefinitionRegistryPostProcessor：ConfigurationClassPostProcessor。ConfigurationClassPostProcessor语义是对配置类的处理，实际上是扫描和注册非代码生成的 BeanDefinition，包括@Configuration、@Import、@ImportSource、@Bean、@Component。理解ConfigurationClassPostProcessor关系到 Bean 注册和 Spring Boot 自动装配。","text":"在前面(二) PostProcesser章节中提到过一个重要的BeanDefinitionRegistryPostProcessor：ConfigurationClassPostProcessor。ConfigurationClassPostProcessor语义是对配置类的处理，实际上是扫描和注册非代码生成的 BeanDefinition，包括@Configuration、@Import、@ImportSource、@Bean、@Component。理解ConfigurationClassPostProcessor关系到 Bean 注册和 Spring Boot 自动装配。 ConfigurationClassPostProcessorConfigurationClassPostProcessor是配置类的处理器。 public class ConfigurationClassPostProcessor implements BeanDefinitionRegistryPostProcessor, PriorityOrdered, ResourceLoaderAware, BeanClassLoaderAware, EnvironmentAware 导入时机AnnotationConfigUtils#registerAnnotationConfigProcessors引入： public static Set&lt;BeanDefinitionHolder> registerAnnotationConfigProcessors( BeanDefinitionRegistry registry, @Nullable Object source) &#123; if (!registry.containsBeanDefinition(CONFIGURATION_ANNOTATION_PROCESSOR_BEAN_NAME)) &#123; RootBeanDefinition def = new RootBeanDefinition(ConfigurationClassPostProcessor.class); def.setSource(source); beanDefs.add(registerPostProcessor(registry, def, CONFIGURATION_ANNOTATION_PROCESSOR_BEAN_NAME)); &#125; &#125; 执行逻辑ConfigurationClassPostProcessor实现了BeanDefinitionRegistryPostProcessor，自然会在 refresh.invokeBeanFactoryPostProcessors时触发： public void refresh() throws BeansException, IllegalStateException &#123; ...... invokeBeanFactoryPostProcessors(beanFactory); ...... &#125; ConfigurationClassPostProcessor#postProcessBeanDefinitionRegistry可分为三步： 通过ConfigurationClassUtils筛选出根配置类，并且为解析做了一些准备（如 BeanNameGenerator，排序等） ConfigurationClassParser解析出所有的配置类 ConfigurationClassBeanDefinitionReader进行 Bean 注册 // ConfigurationClassPostProcessor#postProcessBeanDefinitionRegistry public void postProcessBeanDefinitionRegistry(BeanDefinitionRegistry registry) &#123; processConfigBeanDefinitions(registry); &#125; public void processConfigBeanDefinitions(BeanDefinitionRegistry registry) &#123; // 记录最初的配置候选类 List&lt;BeanDefinitionHolder> configCandidates = new ArrayList&lt;>(); // 这里一般只有@SpringBootApplication String[] candidateNames = registry.getBeanDefinitionNames(); for (String beanName : candidateNames) &#123; BeanDefinition beanDef = registry.getBeanDefinition(beanName); if (beanDef.getAttribute(ConfigurationClassUtils.CONFIGURATION_CLASS_ATTRIBUTE) != null) &#123;&#125; // 筛选出配置类（包括full与lite模式） else if (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)) &#123; configCandidates.add(new BeanDefinitionHolder(beanDef, beanName)); &#125; &#125; SingletonBeanRegistry sbr = null; // DefaultListableBeanFactory 当然是单例注册类 if (registry instanceof SingletonBeanRegistry) &#123; sbr = (SingletonBeanRegistry) registry; if (!this.localBeanNameGeneratorSet) &#123; // 检测是否有自定义的名字生成器 BeanNameGenerator generator = (BeanNameGenerator) sbr.getSingleton( AnnotationConfigUtils.CONFIGURATION_BEAN_NAME_GENERATOR); if (generator != null) &#123; this.componentScanBeanNameGenerator = generator; this.importBeanNameGenerator = generator; &#125; &#125; &#125; // 委派ConfigurationClassParser解析@Configuration class ConfigurationClassParser parser = new ConfigurationClassParser( this.metadataReaderFactory, this.problemReporter, this.environment, this.resourceLoader, this.componentScanBeanNameGenerator, registry); Set&lt;BeanDefinitionHolder> candidates = new LinkedHashSet&lt;>(configCandidates); Set&lt;ConfigurationClass> alreadyParsed = new HashSet&lt;>(configCandidates.size()); do &#123; // 从启动类开始解析 parser.parse(candidates); parser.validate(); // 获取所有配置类，并将 PrimeSource 排除掉 Set&lt;ConfigurationClass> configClasses = new LinkedHashSet&lt;>(parser.getConfigurationClasses()); configClasses.removeAll(alreadyParsed); if (this.reader == null) &#123; this.reader = new ConfigurationClassBeanDefinitionReader( registry, this.sourceExtractor, this.resourceLoader, this.environment, this.importBeanNameGenerator, parser.getImportRegistry()); &#125; // 委派ConfigurationClassBeanDefinitionReader 进行类注册 this.reader.loadBeanDefinitions(configClasses); ...... &#125; ConfigurationClassUtilsConfigurationClassUtils是一个负责判断配置类的工具类。注意配置类并不一定需要标记@Configuration。 checkConfigurationClassCandidateConfigurationClassUtils#checkConfigurationClassCandidate判断一个类是否是@Configuration标记（区分 full 模式与 lite 模式）： // ConfigurationClassUtils#checkConfigurationClassCandidate public static boolean checkConfigurationClassCandidate( BeanDefinition beanDef, MetadataReaderFactory metadataReaderFactory) &#123; Map&lt;String, Object> config = metadata.getAnnotationAttributes(Configuration.class.getName()); // 根据@Configuration的proxyBeanMethods值来标记是full类型还是lite类型 if (config != null &amp;&amp; !Boolean.FALSE.equals(config.get(\"proxyBeanMethods\"))) &#123; beanDef.setAttribute(CONFIGURATION_CLASS_ATTRIBUTE, CONFIGURATION_CLASS_FULL); &#125; // else if (config != null || isConfigurationCandidate(metadata)) &#123; beanDef.setAttribute(CONFIGURATION_CLASS_ATTRIBUTE, CONFIGURATION_CLASS_LITE); &#125; return true; &#125; isConfigurationCandidateConfigurationClassUtils#isConfigurationCandidate的功能是判断是否是 lite 模式下的Configuration: @Component||@ComponentScan||@Import||@ImportResource||@Bean private static final Set&lt;String> candidateIndicators = new HashSet&lt;>(8); static &#123; candidateIndicators.add(Component.class.getName()); candidateIndicators.add(ComponentScan.class.getName()); candidateIndicators.add(Import.class.getName()); candidateIndicators.add(ImportResource.class.getName()); &#125; // ConfigurationClassUtils#isConfigurationCandidate public static boolean isConfigurationCandidate(AnnotationMetadata metadata) &#123; /** * @Component * @ComponentScan * @Import * @ImportResource */ for (String indicator : candidateIndicators) &#123; if (metadata.isAnnotated(indicator)) &#123; return true; &#125; &#125; try &#123; // 判断是否有 @Bean 注解 return metadata.hasAnnotatedMethods(Bean.class.getName()); &#125; &#125; Full 与 Lite 模式前面说到ConfigurationClassUtils判断是否是配置类，会区分 full 与 lite 模式。区别在于 full 模式会对其进行 CGLIB 代理增强： // ConfigurationClassPostProcessor#postProcessBeanFactory public void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) &#123; ...... // 对FactoryBean#getObject 进行增强 enhanceConfigurationClasses(beanFactory); // 添加一个SmartInstantiationAwareBeanPostProcessor beanFactory.addBeanPostProcessor(new ImportAwareBeanPostProcessor(beanFactory)); &#125; ConfigurationClassPostProcessor#enhanceConfigurationClasses会对full 类型的配置进行代理增强（实际是委托给ConfigurationClassEnhancer）。 // ConfigurationClassPostProcessor#enhanceConfigurationClasses public void enhanceConfigurationClasses(ConfigurableListableBeanFactory beanFactory) &#123; // 存储full类型的配置类 Map&lt;String, AbstractBeanDefinition> configBeanDefs = new LinkedHashMap&lt;>(); for (String beanName : beanFactory.getBeanDefinitionNames()) &#123; ...... // 判断是否是full类型的配置类 if (ConfigurationClassUtils.CONFIGURATION_CLASS_FULL.equals(configClassAttr)) &#123; if (!(beanDef instanceof AbstractBeanDefinition)) &#123; &#125; else if (logger.isInfoEnabled() &amp;&amp; beanFactory.containsSingleton(beanName)) &#123; configBeanDefs.put(beanName, (AbstractBeanDefinition) beanDef); &#125; &#125; ConfigurationClassEnhancer enhancer = new ConfigurationClassEnhancer(); for (Map.Entry&lt;String, AbstractBeanDefinition> entry : configBeanDefs.entrySet()) &#123; AbstractBeanDefinition beanDef = entry.getValue(); // If a @Configuration class gets proxied, always proxy the target class beanDef.setAttribute(AutoProxyUtils.PRESERVE_TARGET_CLASS_ATTRIBUTE, Boolean.TRUE); // Set enhanced subclass of the user-specified bean class Class&lt;?> configClass = beanDef.getBeanClass(); Class&lt;?> enhancedClass = enhancer.enhance(configClass, this.beanClassLoader); if (configClass != enhancedClass) &#123; // 这样实际类型是代理增强后的类 beanDef.setBeanClass(enhancedClass); &#125; &#125; &#125; ConfigurationClassEnhancerConfigurationClassEnhancer增强主要做了以下几件事： 添加EnhancedConfiguration接口（间接实现了BeanFactoryAware） 名称中添加 BySpringCGLIB 添加$$beanFactory字段 增加两个拦截器： BeanMethodInterceptor：注册@Bean方法中执行其他@Bean`的依赖关系 BeanFactoryAwareMethodInterceptor：拦截setBeanFactory时将默认的DefaultListableBeanFactory反射赋值给$$beanFactory字段： // ConfigurationClassEnhancer private static final ConditionalCallbackFilter CALLBACK_FILTER = new ConditionalCallbackFilter(CALLBACKS); // CGLIB 增强用到的回调 private static final Callback[] CALLBACKS = new Callback[] &#123; new BeanMethodInterceptor(), new BeanFactoryAwareMethodInterceptor(), NoOp.INSTANCE &#125;; private Enhancer newEnhancer(Class&lt;?> configSuperClass, @Nullable ClassLoader classLoader) &#123; Enhancer enhancer = new Enhancer(); enhancer.setSuperclass(configSuperClass); // public interface EnhancedConfiguration extends BeanFactoryAware // 这就是为什么增强类会有BeanFactory的引用 enhancer.setInterfaces(new Class&lt;?>[] &#123;EnhancedConfiguration.class&#125;); enhancer.setUseFactory(false); // 名称中会有 BySpringCGLIB enhancer.setNamingPolicy(SpringNamingPolicy.INSTANCE); // ConfigurationClassEnhancer.BeanFactoryAwareGeneratorStrategy#transform 会添加一个`$$beanFactory`字段 enhancer.setStrategy(new BeanFactoryAwareGeneratorStrategy(classLoader)); // 配置拦截器 enhancer.setCallbackFilter(CALLBACK_FILTER); enhancer.setCallbackTypes(CALLBACK_FILTER.getCallbackTypes()); return enhancer; &#125; private Class&lt;?> createClass(Enhancer enhancer) &#123; Class&lt;?> subclass = enhancer.createClass(); Enhancer.registerStaticCallbacks(subclass, CALLBACKS); return subclass; &#125; 添加环境变量-Dcglib.debugLocation=whatever查看反编译后的代理类： public class MybatisApplication$$EnhancerBySpringCGLIB$$afeb6e0a extends MybatisApplication implements EnhancedConfiguration &#123; private boolean CGLIB$BOUND; public static Object CGLIB$FACTORY_DATA; private static final ThreadLocal CGLIB$THREAD_CALLBACKS; private static final Callback[] CGLIB$STATIC_CALLBACKS; private MethodInterceptor CGLIB$CALLBACK_0; private MethodInterceptor CGLIB$CALLBACK_1; private NoOp CGLIB$CALLBACK_2; private static Object CGLIB$CALLBACK_FILTER; private static final Method CGLIB$setBeanFactory$4$Method; private static final MethodProxy CGLIB$setBeanFactory$4$Proxy; private static final Object[] CGLIB$emptyArgs; public BeanFactory $$beanFactory; static void CGLIB$STATICHOOK1() &#123; CGLIB$THREAD_CALLBACKS = new ThreadLocal(); CGLIB$emptyArgs = new Object[0]; Class var0 = Class.forName(\"com.example.mybatis.MybatisApplication$$EnhancerBySpringCGLIB$$afeb6e0a\"); Class var1; CGLIB$setBeanFactory$4$Method = ReflectUtils.findMethods(new String[]&#123;\"setBeanFactory\", \"(Lorg/springframework/beans/factory/BeanFactory;)V\"&#125;, (var1 = Class.forName(\"org.springframework.beans.factory.BeanFactoryAware\")).getDeclaredMethods())[0]; CGLIB$setBeanFactory$4$Proxy = MethodProxy.create(var1, var0, \"(Lorg/springframework/beans/factory/BeanFactory;)V\", \"setBeanFactory\", \"CGLIB$setBeanFactory$4\"); &#125; final void CGLIB$setBeanFactory$4(BeanFactory var1) throws BeansException &#123; super.setBeanFactory(var1); &#125; public final void setBeanFactory(BeanFactory var1) throws BeansException &#123; MethodInterceptor var10000 = this.CGLIB$CALLBACK_1; if (var10000 == null) &#123; CGLIB$BIND_CALLBACKS(this); var10000 = this.CGLIB$CALLBACK_1; &#125; if (var10000 != null) &#123; var10000.intercept(this, CGLIB$setBeanFactory$4$Method, new Object[]&#123;var1&#125;, CGLIB$setBeanFactory$4$Proxy); &#125; else &#123; super.setBeanFactory(var1); &#125; &#125; public static MethodProxy CGLIB$findMethodProxy(Signature var0) &#123; String var10000 = var0.toString(); switch(var10000.hashCode()) &#123; case 2095635076: if (var10000.equals(\"setBeanFactory(Lorg/springframework/beans/factory/BeanFactory;)V\")) &#123; return CGLIB$setBeanFactory$4$Proxy; &#125; &#125; return null; &#125; public MybatisApplication$$EnhancerBySpringCGLIB$$afeb6e0a() &#123; CGLIB$BIND_CALLBACKS(this); &#125; public static void CGLIB$SET_THREAD_CALLBACKS(Callback[] var0) &#123; CGLIB$THREAD_CALLBACKS.set(var0); &#125; public static void CGLIB$SET_STATIC_CALLBACKS(Callback[] var0) &#123; CGLIB$STATIC_CALLBACKS = var0; &#125; private static final void CGLIB$BIND_CALLBACKS(Object var0) &#123; MybatisApplication$$EnhancerBySpringCGLIB$$afeb6e0a var1 = (MybatisApplication$$EnhancerBySpringCGLIB$$afeb6e0a)var0; if (!var1.CGLIB$BOUND) &#123; var1.CGLIB$BOUND = true; Object var10000 = CGLIB$THREAD_CALLBACKS.get(); if (var10000 == null) &#123; var10000 = CGLIB$STATIC_CALLBACKS; if (var10000 == null) &#123; return; &#125; &#125; Callback[] var10001 = (Callback[])var10000; var1.CGLIB$CALLBACK_2 = (NoOp)((Callback[])var10000)[2]; var1.CGLIB$CALLBACK_1 = (MethodInterceptor)var10001[1]; var1.CGLIB$CALLBACK_0 = (MethodInterceptor)var10001[0]; &#125; &#125; static &#123; CGLIB$STATICHOOK2(); CGLIB$STATICHOOK1(); &#125; static void CGLIB$STATICHOOK2() &#123; &#125; &#125; BeanMethodInterceptorBeanMethodInterceptor是ConfigurationClassEnhancer的内部类。 // MethodInterceptor#intercept 对指定方法拦截 // ConditionalCallback#isMatch 匹配拦截的方法 private static class BeanMethodInterceptor implements MethodInterceptor, ConditionalCallback &#123; 主要是拦截@Bean方法，建立@Bean方法中执行其他@Bean`方法创建的实例的依赖关系。比如： @Bean public HikariDataSource dataSource() &#123; HikariConfig hikariConfig = new HikariConfig(); hikariConfig.setDriverClassName(driverClassName); hikariConfig.setJdbcUrl(dataSourceUrl); hikariConfig.setUsername(username); hikariConfig.setPassword(password); return new HikariDataSource(hikariConfig); &#125; @Bean public PlatformTransactionManager dataSourceTransactionManager() &#123; // 这里的dataSource()不会重新创建，而是从容器中取 return new DataSourceTransactionManager(dataSource()); &#125; 匹配拦截// ConfigurationClassEnhancer.BeanMethodInterceptor#isMatch public boolean isMatch(Method candidateMethod) &#123; return (candidateMethod.getDeclaringClass() != Object.class &amp;&amp; // setBeanFactory 排除 !BeanFactoryAwareMethodInterceptor.isSetBeanFactory(candidateMethod) &amp;&amp; // 方法上是否有 @Bean 注释 BeanAnnotationHelper.isBeanAnnotated(candidateMethod)); &#125; 拦截处理public Object intercept(Object enhancedConfigInstance, Method beanMethod, Object[] beanMethodArgs, MethodProxy cglibMethodProxy) throws Throwable &#123; ConfigurableBeanFactory beanFactory = getBeanFactory(enhancedConfigInstance); // 如果没有配置了@Bean(name=xx)，直接用方法名作为@Bean的name String beanName = BeanAnnotationHelper.determineBeanNameFor(beanMethod); // 是否有@Scope注解 if (BeanAnnotationHelper.isScopedProxy(beanMethod)) &#123; String scopedBeanName = ScopedProxyCreator.getTargetBeanName(beanName); if (beanFactory.isCurrentlyInCreation(scopedBeanName)) &#123; beanName = scopedBeanName; &#125; &#125; if (factoryContainsBean(beanFactory, BeanFactory.FACTORY_BEAN_PREFIX + beanName) &amp;&amp; factoryContainsBean(beanFactory, beanName)) &#123; Object factoryBean = beanFactory.getBean(BeanFactory.FACTORY_BEAN_PREFIX + beanName); if (factoryBean instanceof ScopedProxyFactoryBean) &#123; &#125; else &#123; // 增强 FactoryBean return enhanceFactoryBean(factoryBean, beanMethod.getReturnType(), beanFactory, beanName); &#125; &#125; if (isCurrentlyInvokedFactoryMethod(beanMethod)) &#123; return cglibMethodProxy.invokeSuper(enhancedConfigInstance, beanMethodArgs); &#125; // 注册`@Bean方法中执行其他`@Bean`的依赖关系 return resolveBeanReference(beanMethod, beanMethodArgs, beanFactory, beanName); &#125; resolveBeanReferenceConfigurationClassEnhancer.BeanMethodInterceptor#resolveBeanReference会对@Bean注释的方法建立依赖关系。 private Object resolveBeanReference(Method beanMethod, Object[] beanMethodArgs, ConfigurableBeanFactory beanFactory, String beanName) &#123; boolean alreadyInCreation = beanFactory.isCurrentlyInCreation(beanName); try &#123; ...... // 去BeanFactory获取实例 Object beanInstance = (useArgs ? beanFactory.getBean(beanName, beanMethodArgs) : beanFactory.getBean(beanName)); if (!ClassUtils.isAssignableValue(beanMethod.getReturnType(), beanInstance)) &#123; // Detect package-protected NullBean instance through equals(null) check if (beanInstance.equals(null)) &#123; beanInstance = null; &#125; &#125; Method currentlyInvoked = SimpleInstantiationStrategy.getCurrentlyInvokedFactoryMethod(); if (currentlyInvoked != null) &#123; String outerBeanName = BeanAnnotationHelper.determineBeanNameFor(currentlyInvoked); // 注册依赖关系，比如sqlSessionFactory与dataSource beanFactory.registerDependentBean(beanName, outerBeanName); &#125; return beanInstance; &#125; &#125; enhanceFactoryBeanenhanceFactoryBean会创建一个FactoryBean类型的增强类，如果类名或者方法是final且为接口类型的使用JDK代理，非final使用CGLIB代理： // ConfigurationClassEnhancer.BeanMethodInterceptor#enhanceFactoryBean private Object enhanceFactoryBean(final Object factoryBean, Class&lt;?> exposedType, final ConfigurableBeanFactory beanFactory, final String beanName) &#123; try &#123; Class&lt;?> clazz = factoryBean.getClass(); boolean finalClass = Modifier.isFinal(clazz.getModifiers()); boolean finalMethod = Modifier.isFinal(clazz.getMethod(\"getObject\").getModifiers()); // 如果类名或者方法是final if (finalClass || finalMethod) &#123; // 且为接口类型，走JDK代理模式 if (exposedType.isInterface()) &#123; return createInterfaceProxyForFactoryBean(factoryBean, exposedType, beanFactory, beanName); &#125; else &#123; return factoryBean; &#125; &#125; &#125; catch (NoSuchMethodException ex) &#123; &#125; // 创建CGLIB类型的代理类 return createCglibProxyForFactoryBean(factoryBean, beanFactory, beanName); &#125; BeanFactoryAwareMethodInterceptorBeanFactoryAwareMethodInterceptor与BeanMethodInterceptor类似： private static class BeanFactoryAwareMethodInterceptor implements MethodInterceptor, ConditionalCallback &#123; 匹配拦截// ConfigurationClassEnhancer.BeanFactoryAwareMethodInterceptor#isMatch public boolean isMatch(Method candidateMethod) &#123; return isSetBeanFactory(candidateMethod); &#125; public static boolean isSetBeanFactory(Method candidateMethod) &#123; return (candidateMethod.getName().equals(\"setBeanFactory\") &amp;&amp; candidateMethod.getParameterCount() == 1 &amp;&amp; BeanFactory.class == candidateMethod.getParameterTypes()[0] &amp;&amp; BeanFactoryAware.class.isAssignableFrom(candidateMethod.getDeclaringClass())); &#125; 拦截处理拦截处理也非常简单，会拦截setBeanFactory时将默认的DefaultListableBeanFactory反射赋值给$$beanFactory字段： // ConfigurationClassEnhancer.BeanFactoryAwareMethodInterceptor public Object intercept(Object obj, Method method, Object[] args, MethodProxy proxy) throws Throwable &#123; // private static final String BEAN_FACTORY_FIELD = \"$$beanFactory\"; Field field = ReflectionUtils.findField(obj.getClass(), BEAN_FACTORY_FIELD); field.set(obj, args[0]); if (BeanFactoryAware.class.isAssignableFrom(ClassUtils.getUserClass(obj.getClass().getSuperclass()))) &#123; return proxy.invokeSuper(obj, args); &#125; return null; &#125; ConfigurationClassParser刚介绍完了判断配置类以及full模式增强的过程，下面接着看ConfigurationClassParser解析配置类的过程： // ConfigurationClassParser#parse public void parse(Set&lt;BeanDefinitionHolder> configCandidates) &#123; for (BeanDefinitionHolder holder : configCandidates) &#123; BeanDefinition bd = holder.getBeanDefinition(); try &#123; if (bd instanceof AnnotatedBeanDefinition) &#123; // 如果是deferredImportSelector会先缓存至deferredImportSelectorHandler parse(((AnnotatedBeanDefinition) bd).getMetadata(), holder.getBeanName()); &#125; &#125; &#125; // 处理上面parse过程中缓存的deferredImportSelector this.deferredImportSelectorHandler.process(); &#125; protected final void parse(AnnotationMetadata metadata, String beanName) throws IOException &#123; processConfigurationClass(new ConfigurationClass(metadata, beanName), DEFAULT_EXCLUSION_FILTER); &#125; // ConfigurationClassParser#processConfigurationClass protected void processConfigurationClass(ConfigurationClass configClass, Predicate&lt;String> filter) throws IOException &#123; // 根据@Condition进行过滤 if (this.conditionEvaluator.shouldSkip(configClass.getMetadata(), ConfigurationPhase.PARSE_CONFIGURATION)) &#123; return; &#125; // 递归解析 do &#123; sourceClass = doProcessConfigurationClass(configClass, sourceClass, filter); &#125; while (sourceClass != null); this.configurationClasses.put(configClass, configClass); &#125; ConfigurationClassParser#doProcessConfigurationClass会依次处理： 递归处理内部类先 处理@PropertySources注解：解析属性文件 处理@ComponentScan注解（通过ClassPathBeanDefinitionScanner解析） 处理@Import导入类（Spring Boot 自动装配的原理之一） 处理@ImportResource注解 处理@Bean注解：获取被@Bean注解修饰的方法，添加到配置类的 beanMethods 属性 // ConfigurationClassParser#doProcessConfigurationClass protected final SourceClass doProcessConfigurationClass( ConfigurationClass configClass, SourceClass sourceClass, Predicate&lt;String> filter) throws IOException &#123; if (configClass.getMetadata().isAnnotated(Component.class.getName())) &#123; // ① 递归处理内部类先 processMemberClasses(configClass, sourceClass, filter); &#125; // ② 处理`@PropertySources`注解,解析属性文件 for (AnnotationAttributes propertySource : AnnotationConfigUtils.attributesForRepeatable( sourceClass.getMetadata(), PropertySources.class, org.springframework.context.annotation.PropertySource.class)) &#123; if (this.environment instanceof ConfigurableEnvironment) &#123; processPropertySource(propertySource); &#125; &#125; // ③ 处理 @ComponentScan 注解 Set&lt;AnnotationAttributes> componentScans = AnnotationConfigUtils.attributesForRepeatable( sourceClass.getMetadata(), ComponentScans.class, ComponentScan.class); if (!componentScans.isEmpty() &amp;&amp; !this.conditionEvaluator.shouldSkip(sourceClass.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) &#123; for (AnnotationAttributes componentScan : componentScans) &#123; // The config class is annotated with @ComponentScan -> perform the scan immediately Set&lt;BeanDefinitionHolder> scannedBeanDefinitions = this.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName()); for (BeanDefinitionHolder holder : scannedBeanDefinitions) &#123; BeanDefinition bdCand = holder.getBeanDefinition().getOriginatingBeanDefinition(); if (bdCand == null) &#123; bdCand = holder.getBeanDefinition(); &#125; // 再次判断配置类 if (ConfigurationClassUtils.checkConfigurationClassCandidate(bdCand, this.metadataReaderFactory)) &#123; parse(bdCand.getBeanClassName(), holder.getBeanName()); &#125; &#125; &#125; &#125; // ④ 处理 @Import processImports(configClass, sourceClass, getImports(sourceClass), filter, true); // ⑤ 处理`@ImportResource`注解 AnnotationAttributes importResource = AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ImportResource.class); if (importResource != null) &#123; String[] resources = importResource.getStringArray(\"locations\"); Class&lt;? extends BeanDefinitionReader> readerClass = importResource.getClass(\"reader\"); for (String resource : resources) &#123; String resolvedResource = this.environment.resolveRequiredPlaceholders(resource); configClass.addImportedResource(resolvedResource, readerClass); &#125; &#125; // ⑥ 处理`@Bean`注解：获取被@Bean注解修饰的方法，添加到配置类的beanMethods属性 Set&lt;MethodMetadata> beanMethods = retrieveBeanMethodMetadata(sourceClass); for (MethodMetadata methodMetadata : beanMethods) &#123; configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass)); &#125; return null; &#125; 扫描注册 ComponentComponentScanAnnotationParser实际委派给ClassPathBeanDefinitionScanner扫描： // ComponentScanAnnotationParser#parse public Set&lt;BeanDefinitionHolder> parse(AnnotationAttributes componentScan, final String declaringClass) &#123; ClassPathBeanDefinitionScanner scanner = new ClassPathBeanDefinitionScanner(this.registry, componentScan.getBoolean(\"useDefaultFilters\"), this.environment, this.resourceLoader); // 创建 ClassPathBeanDefinitionScanner 并初始化 ...... // 如果没有配置 basePackages 就将primeSource的目录当成根目录 if (basePackages.isEmpty()) &#123; basePackages.add(ClassUtils.getPackageName(declaringClass)); &#125; return scanner.doScan(StringUtils.toStringArray(basePackages)); &#125; ClassPathBeanDefinitionScanner#doScan会扫描并注册默认的@Componont。通常自己开发的项目需要集成 Spring 时，会继承ClassPathBeanDefinitionScanner或者其父类ClassPathScanningCandidateComponentProvider进行自定义扫描。 // ClassPathBeanDefinitionScanner#doScan protected Set&lt;BeanDefinitionHolder> doScan(String... basePackages) &#123; Set&lt;BeanDefinitionHolder> beanDefinitions = new LinkedHashSet&lt;>(); for (String basePackage : basePackages) &#123; // `AnnotationConfigServletWebServerApplicationContext`初始化时会先初始化`ClassPathBeanDefinitionScanner`，默认会注册`@Component`: Set&lt;BeanDefinition> candidates = findCandidateComponents(basePackage); for (BeanDefinition candidate : candidates) &#123; ScopeMetadata scopeMetadata = this.scopeMetadataResolver.resolveScopeMetadata(candidate); candidate.setScope(scopeMetadata.getScopeName()); String beanName = this.beanNameGenerator.generateBeanName(candidate, this.registry); if (candidate instanceof AbstractBeanDefinition) &#123; postProcessBeanDefinition((AbstractBeanDefinition) candidate, beanName); &#125; if (candidate instanceof AnnotatedBeanDefinition) &#123; // 处理 @Lazy、@Primary、@DependsOn、@Role、@Description AnnotationConfigUtils.processCommonDefinitionAnnotations((AnnotatedBeanDefinition) candidate); &#125; if (checkCandidate(beanName, candidate)) &#123; BeanDefinitionHolder definitionHolder = new BeanDefinitionHolder(candidate, beanName); definitionHolder = AnnotationConfigUtils.applyScopedProxyMode(scopeMetadata, definitionHolder, this.registry); beanDefinitions.add(definitionHolder); // 通过`BeanDefinitionReaderUtils#registerBeanDefinition`注册 registerBeanDefinition(definitionHolder, this.registry); &#125; &#125; &#125; return beanDefinitions; &#125; 处理 @Import@Import注解支持三种类型： ImportSelector：继续使用ConfigurationClassParser#processImportsc处理 DeferredImportSelector：最后DeferredImportSelectorHandler统一处理 ImportBeanDefinitionRegistrar：存放在ConfigurationClass#importBeanDefinitionRegistrars，待ConfigurationClassBeanDefinitionReader#loadBeanDefinitions时注册 @Configuration：继续使用ConfigurationClassParser#processConfigurationClass处理配置类 // ConfigurationClassParser#processImports private void processImports(ConfigurationClass configClass, SourceClass currentSourceClass, Collection&lt;SourceClass> importCandidates, Predicate&lt;String> exclusionFilter, boolean checkForCircularImports) &#123; for (SourceClass candidate : importCandidates) &#123; if (candidate.isAssignable(ImportSelector.class)) &#123; // 如果是`ImportSelector` Class&lt;?> candidateClass = candidate.loadClass(); ImportSelector selector = ParserStrategyUtils.instantiateClass(candidateClass, ImportSelector.class, this.environment, this.resourceLoader, this.registry); Predicate&lt;String> selectorFilter = selector.getExclusionFilter(); if (selectorFilter != null) &#123; exclusionFilter = exclusionFilter.or(selectorFilter); &#125; if (selector instanceof DeferredImportSelector) &#123; // DeferredImportSelector 先存在`deferredImportSelectorHandler`，待`ConfigurationClassParser#parse`最后处理 this.deferredImportSelectorHandler.handle(configClass, (DeferredImportSelector) selector); &#125; else &#123; // 如果是普通的`ImportSelector` // 用`ImportSelector#selectImports`包装成`SourceClass`，继续用`processImports`处理。 String[] importClassNames = selector.selectImports(currentSourceClass.getMetadata()); Collection&lt;SourceClass> importSourceClasses = asSourceClasses(importClassNames, exclusionFilter); processImports(configClass, currentSourceClass, importSourceClasses, exclusionFilter, false); &#125; &#125; else if (candidate.isAssignable(ImportBeanDefinitionRegistrar.class)) &#123; // 如果是`ImportBeanDefinitionRegistrar`, 存放在`ConfigurationClass#importBeanDefinitionRegistrars` Class&lt;?> candidateClass = candidate.loadClass(); ImportBeanDefinitionRegistrar registrar = ParserStrategyUtils.instantiateClass(candidateClass, ImportBeanDefinitionRegistrar.class, this.environment, this.resourceLoader, this.registry); configClass.addImportBeanDefinitionRegistrar(registrar, currentSourceClass.getMetadata()); &#125; else &#123; // @Configuration class 继续用`processConfigurationClass`处理 this.importStack.registerImport( currentSourceClass.getMetadata(), candidate.getMetadata().getClassName()); processConfigurationClass(candidate.asConfigClass(configClass), exclusionFilter); &#125; &#125; &#125; DeferredImportSelector 处理DeferredImportSelectorGroupingHandler 处理DeferredImportSelector：通过DeferredImportSelector.Group#process和DeferredImportSelector.Group#selectImports收集，最后继续用ConfigurationClassParser#processImports处理 private class DeferredImportSelectorGroupingHandler &#123; private final Map&lt;Object, DeferredImportSelectorGrouping> groupings = new LinkedHashMap&lt;>(); private final Map&lt;AnnotationMetadata, ConfigurationClass> configurationClasses = new HashMap&lt;>(); public void register(DeferredImportSelectorHolder deferredImport) &#123; Class&lt;? extends Group> group = deferredImport.getImportSelector().getImportGroup(); DeferredImportSelectorGrouping grouping = this.groupings.computeIfAbsent( (group != null ? group : deferredImport), key -> new DeferredImportSelectorGrouping(createGroup(group))); grouping.add(deferredImport); this.configurationClasses.put(deferredImport.getConfigurationClass().getMetadata(), deferredImport.getConfigurationClass()); &#125; public void processGroupImports() &#123; for (DeferredImportSelectorGrouping grouping : this.groupings.values()) &#123; Predicate&lt;String> exclusionFilter = grouping.getCandidateFilter(); /** * 1. DeferredImportSelector.Group#process * 2. DeferredImportSelector.Group#selectImports */ grouping.getImports().forEach(entry -> &#123; ConfigurationClass configurationClass = this.configurationClasses.get(entry.getMetadata()); try &#123; // 最后继续用`ConfigurationClassParser#processImports`处理 processImports(configurationClass, asSourceClass(configurationClass, exclusionFilter), Collections.singleton(asSourceClass(entry.getImportClassName(), exclusionFilter)), exclusionFilter, false); &#125; &#125;); &#125; &#125; private Group createGroup(@Nullable Class&lt;? extends Group> type) &#123; Class&lt;? extends Group> effectiveType = (type != null ? type : DefaultDeferredImportSelectorGroup.class); return ParserStrategyUtils.instantiateClass(effectiveType, Group.class, ConfigurationClassParser.this.environment, ConfigurationClassParser.this.resourceLoader, ConfigurationClassParser.this.registry); &#125; &#125; ConfigurationClassBeanDefinitionReaderConfigurationClassBeanDefinitionReader#loadBeanDefinitions的作用是注册以下： @Import 导入的配置类和ImportBeanDefinitionRegistrar @Bean 方法 @ImportResource导入 Xml 或者 groovy // ConfigurationClassBeanDefinitionReader#loadBeanDefinitions public void loadBeanDefinitions(Set&lt;ConfigurationClass> configurationModel) &#123; for (ConfigurationClass configClass : configurationModel) &#123; loadBeanDefinitionsForConfigurationClass(configClass, trackedConditionEvaluator); &#125; &#125; private void loadBeanDefinitionsForConfigurationClass( ConfigurationClass configClass, TrackedConditionEvaluator trackedConditionEvaluator) &#123; if (configClass.isImported()) &#123; // 如果是被@Import的 @Configuration Class，注册自己 // BeanDefinitionRegistry#registerBeanDefinition registerBeanDefinitionForImportedConfigurationClass(configClass); &#125; // 注册@Bean for (BeanMethod beanMethod : configClass.getBeanMethods()) &#123; // BeanDefinitionRegistry#registerBeanDefinition loadBeanDefinitionsForBeanMethod(beanMethod); &#125; // @ImportResource：通过对应的`BeanDefinitionReader#loadBeanDefinitions`注册来自 groovy 或者XML资源配置的Bean loadBeanDefinitionsFromImportedResources(configClass.getImportedResources()); // ImportBeanDefinitionRegistrar接口：调用`ImportBeanDefinitionRegistrar#registerBeanDefinitions`进行注册 BeanDefinition。 loadBeanDefinitionsFromRegistrars(configClass.getImportBeanDefinitionRegistrars()); &#125; 总结 ConfigurationClassPostProcessor是处理配置类的后置处理器。 AnnotationConfigUtils#registerAnnotationConfigProcessors引入; 实现了BeanDefinitionRegistryPostProcessor，会在 refresh.invokeBeanFactoryPostProcessors时触发； ConfigurationClassPostProcessor处理配置类依靠3个类： ConfigurationClassUtils可以判断是否为配置类，以及配置类模式； ConfigurationClassParser负责解析配置类以及扫描注册； ClassPathBeanDefinitionScanner扫描并注册Component； ConfigurationClassBeanDefinitionReader负责注册被 import 的类、@Bean、@ImportResource、 ConfigurationClassUtils可以判断是否为 Configuration 类以及类型： full： @Configuration(proxyBeanMethods=true) lite： @Configuration(proxyBeanMethods=false) @Component || @ComponentScan || @Import || @ImportResource || @Bean Configuration 类 full 模式会被 CGLIB 代理增强： 添加实现EnhancedConfiguration接口及$$beanFactory字段：EnhancedConfiguration实际继承BeanFactoryAware，会将 BeanFactory set 进代理类。 BeanMethodInterceptor会拦截@Bean方法：确保拿到的是容器中的实例 BeanFactoryAwareMethodInterceptor会拦截setBeanFactory方法：将DefaultListableBeanFactory反射赋值给$$beanFactory字段 ConfigurationClassParser负责对 Configuration 类以及 Component扫描注册： 处理@PropertySources注解：解析属性配置文件 扫描和注册@Component注解(@Configuration派生自@Component) 处理@Import导入类： ImportBeanDefinitionRegistrar：存放在ConfigurationClass#importBeanDefinitionRegistrars ImportSelector：继续使用ConfigurationClassParser#processImports处理 @Configuration：继续使用ConfigurationClassParser#processConfigurationClass处理 处理@ImportResource注解 处理@Bean注解：获取被@Bean注解修饰的方法，添加到配置类的 beanMethods 属性 ConfigurationClassBeanDefinitionReader是注册以下类： @Import 导入的配置类和ImportBeanDefinitionRegistrar @Bean 方法 @ImportResource导入 Xml 或者 groovy","categories":[{"name":"主流框架","slug":"主流框架","permalink":"http://www.niceczj.online/categories/%E4%B8%BB%E6%B5%81%E6%A1%86%E6%9E%B6/"},{"name":"Spring","slug":"主流框架/Spring","permalink":"http://www.niceczj.online/categories/%E4%B8%BB%E6%B5%81%E6%A1%86%E6%9E%B6/Spring/"},{"name":"Spring Framework","slug":"主流框架/Spring/Spring-Framework","permalink":"http://www.niceczj.online/categories/%E4%B8%BB%E6%B5%81%E6%A1%86%E6%9E%B6/Spring/Spring-Framework/"}],"tags":[]},{"title":"(二) PostProcesser","slug":"二-PostProcesser","date":"2020-10-31T16:19:11.000Z","updated":"2020-10-31T16:41:20.643Z","comments":true,"path":"2020/11/01/二-PostProcesser/","link":"","permalink":"http://www.niceczj.online/2020/11/01/%E4%BA%8C-PostProcesser/","excerpt":"什么是 PostProcesserSpring 中提供了多种 PostProcessor（后置处理器）处理 Bean 或者 BeanFactory。PostProcessor 是 Spring 中一个非常重要的扩展点，不同的 PostProcessor 的不同方法会在指定的阶段被执行。很多核心的功能都是由对应的 PostProcessor 扩展而来，比如处理注解注入的AutowiredAnnotationBeanPostProcessor。","text":"什么是 PostProcesserSpring 中提供了多种 PostProcessor（后置处理器）处理 Bean 或者 BeanFactory。PostProcessor 是 Spring 中一个非常重要的扩展点，不同的 PostProcessor 的不同方法会在指定的阶段被执行。很多核心的功能都是由对应的 PostProcessor 扩展而来，比如处理注解注入的AutowiredAnnotationBeanPostProcessor。 容器级别容器级别的 PostProcesser 是为 IOC 容器服务，处理的是整个容器中 BeanDefinitions 。 BeanFactoryPostProcessor顾名思义，BeanFactoryPostProcessor是 Spring 中的底层 IOC 容器 BeanFactory 的后置处理器。 方法：修改 BeanDefinition该接口只有一个方法，会在 Bean 实例化前修改 BeanDefinition： @FunctionalInterface public interface BeanFactoryPostProcessor &#123; /** * 在bean factory 初始化之后，修改 bean definition * 此时 bean definition 已加载但未实例化 */ void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException; &#125; 执行时机BeanFactoryPostProcessor#postProcessBeanFactory会在 refresh 中执行 Bean 处理前执行。实际上全部委托给PostProcessorRegistrationDelegate执行。 public void refresh() throws BeansException, IllegalStateException &#123; synchronized (this.startupShutdownMonitor) &#123; try &#123; // BeanFactory的一些准备工作以及一个钩子方法的单独实现 ...... invokeBeanFactoryPostProcessors(beanFactory); ...... //开始进行 Bean 级别的操作 &#125; &#125; &#125; protected void invokeBeanFactoryPostProcessors(ConfigurableListableBeanFactory beanFactory) &#123; // 全部委托给`PostProcessorRegistrationDelegate`执行 PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors(beanFactory, getBeanFactoryPostProcessors()); &#125; BeanDefinitionRegistryPostProcessorBeanDefinitionRegistryPostProcessor继承于BeanFactoryPostProcessor。BeanDefinitionRegistryPostProcessor有一些很重要的实现类，比如ConfigurationClassPostProcessor，该后置处理器会在(三) ConfigurationClassPostProcessor中详细解析。 方法：注册新的 BeanDefinitionBeanDefinitionRegistryPostProcessor额外提供了一个方法用于注册新的 BeanDefinition： public interface BeanDefinitionRegistryPostProcessor extends BeanFactoryPostProcessor &#123; /** * 在 BeanDefinitionRegistry 初始化之后，注册新的 bean definition */ void postProcessBeanDefinitionRegistry(BeanDefinitionRegistry registry) throws BeansException; &#125; 执行时机BeanDefinitionRegistryPostProcessor由于是BeanFactoryPostProcessor子类，所以也是被当做BeanFactoryPostProcessor一样在PostProcessorRegistrationDelegate#invokeBeanFactoryPostProcessors执行。但是BeanDefinitionRegistryPostProcessor#postProcessBeanDefinitionRegistry的语义是注册 BeanDefinition，所以他的执行时机是在修改 BeanDefinition，也就是普通的BeanFactoryPostProcessor#postProcessBeanFactory前面的。 invokeBeanFactoryPostProcessors跟踪PostProcessorRegistrationDelegate#invokeBeanFactoryPostProcessors可以了解BeanFactoryPostProcessor以及BeanDefinitionRegistryPostProcessor的执行逻辑： 获取refresh前注册的BeanFactoryPostProcessor以及容器中查找到的BeanDefinitionRegistryPostProcessor; 按照PriorityOrdered、Ordered、普通这个顺序执行BeanDefinitionRegistryPostProcessor#postProcessBeanDefinitionRegistry; 再按照BeanDefinitionRegistryPostProcessor、BeanFactoryPostProcessor的顺序执行postProcessBeanFactory; 获取容器中查找到的BeanFactoryPostProcessor; 按照PriorityOrdered、Ordered、普通这个顺序执行BeanFactoryPostProcessor#postProcessBeanFactory; public static void invokeBeanFactoryPostProcessors( ConfigurableListableBeanFactory beanFactory, List&lt;BeanFactoryPostProcessor> beanFactoryPostProcessors) &#123; Set&lt;String> processedBeans = new HashSet&lt;>(); // 先执行 BeanDefinitionRegistryPostProcessors if (beanFactory instanceof BeanDefinitionRegistry) &#123; BeanDefinitionRegistry registry = (BeanDefinitionRegistry) beanFactory; // BeanFactoryPostProcessors List&lt;BeanFactoryPostProcessor> regularPostProcessors = new ArrayList&lt;>(); // BeanDefinitionRegistryPostProcessors List&lt;BeanDefinitionRegistryPostProcessor> registryProcessors = new ArrayList&lt;>(); // 先分类，如果`BeanDefinitionRegistryPostProcessor`就先执行 for (BeanFactoryPostProcessor postProcessor : beanFactoryPostProcessors) &#123; if (postProcessor instanceof BeanDefinitionRegistryPostProcessor) &#123; BeanDefinitionRegistryPostProcessor registryProcessor = (BeanDefinitionRegistryPostProcessor) postProcessor; registryProcessor.postProcessBeanDefinitionRegistry(registry); registryProcessors.add(registryProcessor); &#125; else &#123; regularPostProcessors.add(postProcessor); &#125; &#125; // 先执行实现了`PriorityOrdered`的`BeanDefinitionRegistryPostProcessors` List&lt;BeanDefinitionRegistryPostProcessor> currentRegistryProcessors = new ArrayList&lt;>(); String[] postProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, true, false); for (String ppName : postProcessorNames) &#123; if (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) &#123; currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class)); processedBeans.add(ppName); &#125; &#125; sortPostProcessors(currentRegistryProcessors, beanFactory); registryProcessors.addAll(currentRegistryProcessors); invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry); currentRegistryProcessors.clear(); // 再执行实现了`Ordered`的`BeanDefinitionRegistryPostProcessors` postProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, true, false); for (String ppName : postProcessorNames) &#123; if (!processedBeans.contains(ppName) &amp;&amp; beanFactory.isTypeMatch(ppName, Ordered.class)) &#123; currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class)); processedBeans.add(ppName); &#125; &#125; sortPostProcessors(currentRegistryProcessors, beanFactory); registryProcessors.addAll(currentRegistryProcessors); invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry); currentRegistryProcessors.clear(); // 最后执行普通的`BeanDefinitionRegistryPostProcessors` boolean reiterate = true; while (reiterate) &#123; reiterate = false; postProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, true, false); for (String ppName : postProcessorNames) &#123; if (!processedBeans.contains(ppName)) &#123; currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class)); processedBeans.add(ppName); reiterate = true; &#125; &#125; sortPostProcessors(currentRegistryProcessors, beanFactory); registryProcessors.addAll(currentRegistryProcessors); invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry); currentRegistryProcessors.clear(); &#125; // 执行完了`BeanDefinitionRegistryPostProcessors#postProcessBeanDefinitionRegistry` // 再依次执行`BeanDefinitionRegistryPostProcessor#postProcessBeanFactory`、`BeanDefinitionRegistryPostProcessor#postProcessBeanFactory` invokeBeanFactoryPostProcessors(registryProcessors, beanFactory); invokeBeanFactoryPostProcessors(regularPostProcessors, beanFactory); &#125; // Do not initialize FactoryBeans here: We need to leave all regular beans // 再去容器中查找`BeanFactoryPostProcessor` // currentRegistryProcessors 大多数是`ApplicationContextInitializer`或者手动new的，所以这里不会与前面重复 String[] postProcessorNames = beanFactory.getBeanNamesForType(BeanFactoryPostProcessor.class, true, false); ...... // 后面与BeanDefinitionRegistryPostProcessor的逻辑是一样的，也是排序执行 &#125; Bean 级别在 IOC 容器批量修改 Bean Definition 之后，BeanPostProcessor 提供了对单个Bean的后置处理器。 BeanPostProcessorBeanPostProcessor是 Bean 级别后置处理器的父类。 方法：初始化前/** * 在 Bean 实例化之后，初始化之前被执行 */ default Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException &#123; return bean; &#125; 执行时机实例化之后。 方法：初始化后/** * 在 Bean 实例化之后，且初始化后被执行 */ default Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException &#123; return bean; &#125; 执行时机postProcessBeforeInitialization之后。 InstantiationAwareBeanPostProcessorInstantiationAwareBeanPostProcessor 继承自BeanPostProcessor。从名字的语义来看，就是对实例化前后进行了一个 Aware 切面。在 Bean 实例化前后提供了额外三个钩子方法。注意Instantiation 与 Instantization两个单词，前者是实例化，后者是初始化。 方法：实例化前default Object postProcessBeforeInstantiation(Class&lt;?> beanClass, String beanName) throws BeansException &#123; return null; &#125; 执行时机目标对象实例化之前调用，可以用生成代理对象。 方法：实例化后default boolean postProcessAfterInstantiation(Object bean, String beanName) throws BeansException &#123; return true; &#125; 执行时机在目标对象实例化之后调用，这个时候对象已经被实例化，但是该实例的属性还未被设置。 方法：属性值修改对属性值的修改，比如自动装配，就是在这实现的。 &#x2F;** * 对属性值进行修改 *&#x2F; default PropertyValues postProcessProperties(PropertyValues pvs, Object bean, String beanName) throws BeansException &#123; return null; &#125; 执行时机postProcessProperties是postProcessAfterInstantiation执行返回 true 时，才会执行。 SmartInstantiationAwareBeanPostProcessorSmartInstantiationAwareBeanPostProcessor继承自InstantiationAwareBeanPostProcessor。SmartInstantiationAwareBeanPostProcessor 是一个工具类， 方法：预测 postProcessBeforeInstantiation 返回的最终类型@Nullable default Class&lt;?> predictBeanType(Class&lt;?> beanClass, String beanName) throws BeansException &#123; return null; &#125; 方法：确认构造函数SmartInstantiationAwareBeanPostProcessor#determineCandidateConstructors会在实例化（AbstractAutowireCapableBeanFactory#createBeanInstance）中用到 default Constructor&lt;?>[] determineCandidateConstructors(Class&lt;?> beanClass, String beanName) throws BeansException &#123; return null; &#125; 方法：提前暴露的bean引用该方法会在循环依赖处理中被用到。 default Object getEarlyBeanReference(Object bean, String beanName) throws BeansException &#123; return bean; &#125; MergedBeanDefinitionPostProcessorMergedBeanDefinitionPostProcessor是专门处理合并后的RootBeanDefinition（处理继承关系）。 方法：处理合并后的RootBeanDefinitionvoid postProcessMergedBeanDefinition(RootBeanDefinition beanDefinition, Class&lt;?> beanType, String beanName); DestructionAwareBeanPostProcessorDestructionAwareBeanPostProcessor是销毁前的后置处理器。比如CommonAnnotationBeanPostProcessor就会处理标准注解@PreDestroy。 方法：销毁前的处理void postProcessBeforeDestruction(Object bean, String beanName) throws BeansException; 一些重要的PostProcessor 名称 实现接口 作用 ApplicationContextAwareProcessor BeanPostProcessor 执行 Aware 回调 ConfigurationPropertiesBindingPostProcessor BeanPostProcessor 绑定PropertySources 至 对应的@ConfigurationProperties 配置Bean上。如Server.port –&gt; ServerProperties ConfigurationClassPostProcessor BeanDefinitionRegistryPostProcessor 扫描注册配置类以及@Bean、@Component AnnotationAwareAspectJAutoProxyCreator SmartInstantiationAwareBeanPostProcessor 对AOP对象进行代理 CommonAnnotationBeanPostProcessor InstantiationAwareBeanPostProcessor、MergedBeanDefinitionPostProcessor、DestructionAwareBeanPostProcessor 对JSR-250 @Resource、@PostConstruct 、@PreDestroy等注解的支持 AutowiredAnnotationBeanPostProcessor SmartInstantiationAwareBeanPostProcessor、MergedBeanDefinitionPostProcessor 对@Autowire、@Value、@Inject 注入相关注解的支持 ApplicationListenerDetector DestructionAwareBeanPostProcessor、MergedBeanDefinitionPostProcessor ApplicationListener 注册和移除至事件广播器 总结其实 Spring 的作者们的确花了不少时间在命名上。我们只要观察对应后置处理器的语义，基本上就能猜测到改处理器的执行时机。","categories":[{"name":"主流框架","slug":"主流框架","permalink":"http://www.niceczj.online/categories/%E4%B8%BB%E6%B5%81%E6%A1%86%E6%9E%B6/"},{"name":"Spring","slug":"主流框架/Spring","permalink":"http://www.niceczj.online/categories/%E4%B8%BB%E6%B5%81%E6%A1%86%E6%9E%B6/Spring/"},{"name":"Spring Framework","slug":"主流框架/Spring/Spring-Framework","permalink":"http://www.niceczj.online/categories/%E4%B8%BB%E6%B5%81%E6%A1%86%E6%9E%B6/Spring/Spring-Framework/"}],"tags":[]},{"title":"(一) BeanDefinition","slug":"一-BeanDefinition","date":"2020-10-31T16:18:55.000Z","updated":"2020-10-31T19:47:26.993Z","comments":true,"path":"2020/11/01/一-BeanDefinition/","link":"","permalink":"http://www.niceczj.online/2020/11/01/%E4%B8%80-BeanDefinition/","excerpt":"什么是BeanDefinitionBeanDefinition是 bean 在 spring 中的元信息。理解BeanDefinition，对后续列理解 Bean 生命周期非常重要。","text":"什么是BeanDefinitionBeanDefinition是 bean 在 spring 中的元信息。理解BeanDefinition，对后续列理解 Bean 生命周期非常重要。 继承关系重点关注两个子类： AbstractBeanDefinition：核心抽象，定义核心的属性和方法。 GenericBeanDefinition：标准一站式类。兼备RootBeanDefinition与ChildBeanDefinition。并有动态设置父 Bean 的能力。 名称 作用 AbstractBeanDefinition 核心抽象，定义核心的属性和方法。其他的所有实现类都继承或者组合它。 AnnotatedBeanDefinition 拥有注解元数据和工厂方法元数据接口。 RootBeanDefinition merged 后的 BeanDefinition。 ChildBeanDefinition 可以让子 BeanDefinition 继承父 BeanDefinition 的能力。 GenericBeanDefinition 标准一站式类。兼备RootBeanDefinition与ChildBeanDefinition。并有动态设置父 Bean 的能力 AnnotatedGenericBeanDefinition @Configuration配置类的元数据。 ScannedGenericBeanDefinition @Component元数据。 核心属性 字段 xml配置 注解配置 作用 beanClass &lt;bean class=&quot;&quot;&gt; Bean 全限定名，必须是可初始化的具体类。 beanName &lt;bean id=&quot;&quot;&gt; @Bean(&quot;&quot;) scope &lt;bean scope=&quot;&quot;&gt; @Scope 作用域。singleton、prototype 等 constructorArgumentValues &lt;constructor-arg type=&quot;int&quot; value=&quot;7500000&quot;/&gt; 构造器参数。用于依赖注入。 propertyValues &lt;property name=&quot;beanTwo&quot; ref=&quot;yetAnotherBean&quot;/&gt; 属性设置。用于依赖注入。 autowireMode &lt;bean id=&quot;user&quot; autowire=&quot;&quot;&gt; 默认是NO，即需要通过注解@autowire等注解显式的注入 initMethodName &lt;bean init-method=&quot;&quot; &gt; @Bean(initMethod =&quot;&quot; destroyMethodName &lt;bean destroy-method=&quot;&quot;&gt; @Bean(destroyMethod = &quot;&quot;) dependsOn &lt;bean depends-on=&quot;&quot;&gt; @DependsOn lazyInit &lt;bean lazy-init=&quot;&quot;&gt; @Lazy 是否懒加载 primary &lt;bean primary=&quot;&quot;&gt; @primary 是否为首选项 factoryBeanName &lt;bean factory-bean=&quot;&quot;&gt; 构造正如继承关系所说，GenericBeanDefinition是最常用的实现类，官方也对应的提供了构造类BeanDefinitionBuilder： protected final AbstractBeanDefinition parseInternal(Element element, ParserContext parserContext) &#123; BeanDefinitionBuilder builder = BeanDefinitionBuilder.genericBeanDefinition(); builder.setLazyInit(true); return builder.getBeanDefinition(); &#125; 其他的实现类利用构造函数new即可。 注册手动构造BeanDefinition后，我们也需要手动注册到容器中去： 带名字BeanDefinitionRegistry#registerBeanDefinitionConfigurationClassBeanDefinitionReader#loadBeanDefinitions就有用到这个 API。 public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) &#123; BeanDefinition annotationProcessor = BeanDefinitionBuilder .genericBeanDefinition(PropertySourcesPlaceholderConfigurer.class) .getBeanDefinition(); registry.registerBeanDefinition( PropertySouorcesPlaceholderConfigurer.class.getName(), annotationProcessor); &#125; BeanDefinitionReaderUtils.registerBeanDefinition这种方式也就是 Spring 扫描注册 Component（ClassPathBeanDefinitionScanner#doScan）的底层实现。 BeanDefinitionHolder definitionHolder = new BeanDefinitionHolder(abd, beanName); definitionHolder = AnnotationConfigUtils.applyScopedProxyMode(scopeMetadata, definitionHolder, this.registry); BeanDefinitionReaderUtils.registerBeanDefinition(definitionHolder, this.registry); 不带名字BeanDefinitionReaderUtils#registerWithGeneratedNameprivate void registerServiceAnnotationBeanPostProcessor(Set&lt;String> packagesToScan, BeanDefinitionRegistry registry) &#123; BeanDefinitionBuilder builder = rootBeanDefinition(ServiceAnnotationBeanPostProcessor.class); builder.addConstructorArgValue(packagesToScan); builder.setRole(BeanDefinition.ROLE_INFRASTRUCTURE); AbstractBeanDefinition beanDefinition = builder.getBeanDefinition(); BeanDefinitionReaderUtils.registerWithGeneratedName(beanDefinition, registry); &#125; 直接注册实例对象SingletonBeanRegistry#registerSingleton除了BeanDefinition之外，你也可以直接注册实例对象： context.getBeanFactory(). registerSingleton(AnnotationConfigUtils.CONFIGURATION_BEAN_NAME_GENERATOR,this.beanNameGenerator);","categories":[{"name":"主流框架","slug":"主流框架","permalink":"http://www.niceczj.online/categories/%E4%B8%BB%E6%B5%81%E6%A1%86%E6%9E%B6/"},{"name":"Spring","slug":"主流框架/Spring","permalink":"http://www.niceczj.online/categories/%E4%B8%BB%E6%B5%81%E6%A1%86%E6%9E%B6/Spring/"},{"name":"Spring Framework","slug":"主流框架/Spring/Spring-Framework","permalink":"http://www.niceczj.online/categories/%E4%B8%BB%E6%B5%81%E6%A1%86%E6%9E%B6/Spring/Spring-Framework/"}],"tags":[]},{"title":"(零) Spring Framework系列纲要","slug":"零-Spring-Framework系列纲要","date":"2020-10-31T16:17:50.000Z","updated":"2020-11-08T14:45:25.534Z","comments":true,"path":"2020/11/01/零-Spring-Framework系列纲要/","link":"","permalink":"http://www.niceczj.online/2020/11/01/%E9%9B%B6-Spring-Framework%E7%B3%BB%E5%88%97%E7%BA%B2%E8%A6%81/","excerpt":"","text":"《Spring Framework系列》是笔者准备用最小的篇幅，结合源码总结 Spring Framework 中的最核心和最常用的模块。目的是拥有可以快速排查问题以及个人项目集成 Spring 的能力。目前计划分为以下几个章节： (一) BeanDefinition (二) PostProcesser (三) ConfigurationClassPostProcessor (四) Spring Event (五) 依赖查找 (六) 循环依赖 (七) refresh TODO","categories":[{"name":"主流框架","slug":"主流框架","permalink":"http://www.niceczj.online/categories/%E4%B8%BB%E6%B5%81%E6%A1%86%E6%9E%B6/"},{"name":"Spring","slug":"主流框架/Spring","permalink":"http://www.niceczj.online/categories/%E4%B8%BB%E6%B5%81%E6%A1%86%E6%9E%B6/Spring/"},{"name":"Spring Framework","slug":"主流框架/Spring/Spring-Framework","permalink":"http://www.niceczj.online/categories/%E4%B8%BB%E6%B5%81%E6%A1%86%E6%9E%B6/Spring/Spring-Framework/"}],"tags":[]}],"categories":[{"name":"主流框架","slug":"主流框架","permalink":"http://www.niceczj.online/categories/%E4%B8%BB%E6%B5%81%E6%A1%86%E6%9E%B6/"},{"name":"Spring","slug":"主流框架/Spring","permalink":"http://www.niceczj.online/categories/%E4%B8%BB%E6%B5%81%E6%A1%86%E6%9E%B6/Spring/"},{"name":"Spring Framework","slug":"主流框架/Spring/Spring-Framework","permalink":"http://www.niceczj.online/categories/%E4%B8%BB%E6%B5%81%E6%A1%86%E6%9E%B6/Spring/Spring-Framework/"}],"tags":[]}